<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pion-net: pion::net::HTTPParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespacepion.html">pion</a>::<a class="el" href="namespacepion_1_1net.html">net</a>::<a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html">HTTPParser</a></div>
<h1>pion::net::HTTPParser Class Reference</h1><!-- doxytag: class="pion::net::HTTPParser" --><code>#include &lt;<a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>&gt;</code>
<p>
Inherited by <a class="el" href="classpion_1_1net_1_1_h_t_t_p_reader.html">pion::net::HTTPReader</a>.
<p>
<a href="classpion_1_1net_1_1_h_t_t_p_parser-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html">HTTPParser</a>: parses HTTP messages 
<p>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00031">31</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#776a8378586ece49d07f954fe5c7f9cd">HTTPParser</a> (const bool is_request, std::size_t max_content_length=<a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#e50d68030598ba2a9f8475179edbf398">DEFAULT_CONTENT_MAX</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7741fab07c210b73994b031cb9e36658"></a><!-- doxytag: member="pion::net::HTTPParser::~HTTPParser" ref="7741fab07c210b73994b031cb9e36658" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#7741fab07c210b73994b031cb9e36658">~HTTPParser</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default destructor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tribool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#450e7a7a4c84afdfea735e45871fdfc1">parse</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tribool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#a6bd7d9a08d575a88aec8b91d65cbe83">parseMissingData</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg, std::size_t len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#83fc56eb643b4afdae3b566d5e68220d">finish</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#24023fdadcccbf6deb536055a30f6cf0">setReadBuffer</a> (const char *ptr, size_t len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#7e465ebe75416fa00586f1238e73c03b">loadReadPosition</a> (const char *&amp;read_ptr, const char *&amp;read_end_ptr) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#285653cf89377a547dbefb452831fcf1">checkPrematureEOF</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b940378889fc5aefa61ef871d2b6f00"></a><!-- doxytag: member="pion::net::HTTPParser::reset" ref="8b940378889fc5aefa61ef871d2b6f00" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#8b940378889fc5aefa61ef871d2b6f00">reset</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resets the parser to its initial state <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6190de184276528cabaf4648d59d3bc0"></a><!-- doxytag: member="pion::net::HTTPParser::eof" ref="6190de184276528cabaf4648d59d3bc0" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#6190de184276528cabaf4648d59d3bc0">eof</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if there are no more bytes available in the read buffer <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97e86fabd35d3656f4aec5afd1075244"></a><!-- doxytag: member="pion::net::HTTPParser::bytes_available" ref="97e86fabd35d3656f4aec5afd1075244" args="(void) const " -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#97e86fabd35d3656f4aec5afd1075244">bytes_available</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the number of bytes available in the read buffer <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b11737293e0a2b617f9b8715796515f"></a><!-- doxytag: member="pion::net::HTTPParser::gcount" ref="8b11737293e0a2b617f9b8715796515f" args="(void) const " -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#8b11737293e0a2b617f9b8715796515f">gcount</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the number of bytes read during the last parse operation <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="231b404dd8250d202481d859a42680db"></a><!-- doxytag: member="pion::net::HTTPParser::getTotalBytesRead" ref="231b404dd8250d202481d859a42680db" args="(void) const " -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#231b404dd8250d202481d859a42680db">getTotalBytesRead</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the total number of bytes read while parsing the HTTP message <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf91f5c10890a5a380e63db9eb38e272"></a><!-- doxytag: member="pion::net::HTTPParser::getContentBytesRead" ref="cf91f5c10890a5a380e63db9eb38e272" args="(void) const " -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#cf91f5c10890a5a380e63db9eb38e272">getContentBytesRead</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the total number of bytes read while parsing the payload content <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="07769e093105bca08076c76592e3be81"></a><!-- doxytag: member="pion::net::HTTPParser::getMaxContentLength" ref="07769e093105bca08076c76592e3be81" args="(void) const " -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#07769e093105bca08076c76592e3be81">getMaxContentLength</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the maximum length for HTTP payload content <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b01ac96a5cc36086e6cb0d7d740499f"></a><!-- doxytag: member="pion::net::HTTPParser::getRawHeaders" ref="1b01ac96a5cc36086e6cb0d7d740499f" args="(void) const " -->
const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#1b01ac96a5cc36086e6cb0d7d740499f">getRawHeaders</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the raw HTTP headers saved by the parser <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0372501f88d0d2ae014f309a0b1d6036"></a><!-- doxytag: member="pion::net::HTTPParser::getSaveRawHeaders" ref="0372501f88d0d2ae014f309a0b1d6036" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#0372501f88d0d2ae014f309a0b1d6036">getSaveRawHeaders</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the parser is saving raw HTTP header contents <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7c90d4fc1b008b2118d3960a81b40de"></a><!-- doxytag: member="pion::net::HTTPParser::isParsingRequest" ref="a7c90d4fc1b008b2118d3960a81b40de" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#a7c90d4fc1b008b2118d3960a81b40de">isParsingRequest</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the parser is being used to parse an HTTP request <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4033f77e347241c7d02f8f35b3c30afe"></a><!-- doxytag: member="pion::net::HTTPParser::isParsingResponse" ref="4033f77e347241c7d02f8f35b3c30afe" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#4033f77e347241c7d02f8f35b3c30afe">isParsingResponse</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true if the parser is being used to parse an HTTP response <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="43fd3b6c38223c60ff88230a4a39d793"></a><!-- doxytag: member="pion::net::HTTPParser::setMaxContentLength" ref="43fd3b6c38223c60ff88230a4a39d793" args="(std::size_t n)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#43fd3b6c38223c60ff88230a4a39d793">setMaxContentLength</a> (std::size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the maximum length for HTTP payload content <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="32214ac2be1f412d8f4825ac096324b2"></a><!-- doxytag: member="pion::net::HTTPParser::resetMaxContentLength" ref="32214ac2be1f412d8f4825ac096324b2" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#32214ac2be1f412d8f4825ac096324b2">resetMaxContentLength</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">resets the maximum length for HTTP payload content to the default value <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0620bde646e241a1341a52426862ab9"></a><!-- doxytag: member="pion::net::HTTPParser::setSaveRawHeaders" ref="b0620bde646e241a1341a52426862ab9" args="(bool b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#b0620bde646e241a1341a52426862ab9">setSaveRawHeaders</a> (bool b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets parameter for saving raw HTTP header content <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ea89631a33380a2d326cbf3d928cd0f1"></a><!-- doxytag: member="pion::net::HTTPParser::setLogger" ref="ea89631a33380a2d326cbf3d928cd0f1" args="(PionLogger log_ptr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#ea89631a33380a2d326cbf3d928cd0f1">setLogger</a> (<a class="el" href="structpion_1_1_pion_logger.html">PionLogger</a> log_ptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the logger to be used <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2b737c4d77025a8213bb9d04a997677d"></a><!-- doxytag: member="pion::net::HTTPParser::getLogger" ref="2b737c4d77025a8213bb9d04a997677d" args="(void)" -->
<a class="el" href="structpion_1_1_pion_logger.html">PionLogger</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#2b737c4d77025a8213bb9d04a997677d">getLogger</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the logger currently in use <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#b64c3586c434f51057ac320a96cfacf4">contentTypeIsUrlEncoded</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_request.html">HTTPRequest</a> &amp;http_request)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#cb14285ae8bfbf8e2f026afc3906e77a">parseURLEncoded</a> (<a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#5dbaae025e754a4862957d17e2e7d9cf">HTTPTypes::QueryParams</a> &amp;dict, const char *ptr, const std::size_t len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#385cb266ce38ce7709049fcd0af085c2">parseCookieHeader</a> (<a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#50fb5b59b0a6ad3eab753800cf78f4fb">HTTPTypes::CookieParams</a> &amp;dict, const char *ptr, const std::size_t len, bool set_cookie_header)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#dffe57bbd26bf724ff0fb712504cf3b4">parseCookieHeader</a> (<a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#50fb5b59b0a6ad3eab753800cf78f4fb">HTTPTypes::CookieParams</a> &amp;dict, const std::string &amp;cookie_header, bool set_cookie_header)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#6c98f37d882e62417ba3032e4673c2fd">parseURLEncoded</a> (<a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#5dbaae025e754a4862957d17e2e7d9cf">HTTPTypes::QueryParams</a> &amp;dict, const std::string &amp;query)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e50d68030598ba2a9f8475179edbf398"></a><!-- doxytag: member="pion::net::HTTPParser::DEFAULT_CONTENT_MAX" ref="e50d68030598ba2a9f8475179edbf398" args="" -->
static const std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#e50d68030598ba2a9f8475179edbf398">DEFAULT_CONTENT_MAX</a> = 1024 * 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for HTTP payload content <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tribool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#71858af1a78971cca63764900e4b255e">parseHeaders</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#c6211a4748e0480ddc765cbf89b8deb8">updateMessageWithHeaderData</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tribool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#590be730e45ea17b7facd8e36bc6b913">finishHeaderParsing</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tribool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#68070cc190f935ffddd6be3d149988da">parseChunks</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html#3f51e42afcccf433e7992b55b9797d13">HTTPMessage::ChunkCache</a> &amp;chunk_buffers)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">boost::tribool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#9fa69e3cd5d84098734c48b31c4149e4">consumeContent</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#5e8a3afc3ab4a7ec7d54e972f539d1d2">consumeContentAsNextChunk</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html#3f51e42afcccf433e7992b55b9797d13">HTTPMessage::ChunkCache</a> &amp;chunk_buffers)</td></tr>

<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#1bd923adaa4867eccc6591d8137c0b9d">computeMsgStatus</a> (<a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;http_msg, bool msg_parsed_ok)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="511861d764184e8145f38275e5c5fa6c"></a><!-- doxytag: member="pion::net::HTTPParser::isChar" ref="511861d764184e8145f38275e5c5fa6c" args="(int c)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#511861d764184e8145f38275e5c5fa6c">isChar</a> (int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac52ae6d53099d73e9d6d65c0b525ff4"></a><!-- doxytag: member="pion::net::HTTPParser::isControl" ref="ac52ae6d53099d73e9d6d65c0b525ff4" args="(int c)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#ac52ae6d53099d73e9d6d65c0b525ff4">isControl</a> (int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77fef6b52fe81fb5a91f145f35ad91dd"></a><!-- doxytag: member="pion::net::HTTPParser::isSpecial" ref="77fef6b52fe81fb5a91f145f35ad91dd" args="(int c)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#77fef6b52fe81fb5a91f145f35ad91dd">isSpecial</a> (int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c976d53db596d817ca0b82c642154f8"></a><!-- doxytag: member="pion::net::HTTPParser::isDigit" ref="6c976d53db596d817ca0b82c642154f8" args="(int c)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#6c976d53db596d817ca0b82c642154f8">isDigit</a> (int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a529564ec63aa8e8ec234a734d3202ef"></a><!-- doxytag: member="pion::net::HTTPParser::isHexDigit" ref="a529564ec63aa8e8ec234a734d3202ef" args="(int c)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#a529564ec63aa8e8ec234a734d3202ef">isHexDigit</a> (int c)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f95b22e50db62dd7475e308390e1bbfc"></a><!-- doxytag: member="pion::net::HTTPParser::isCookieAttribute" ref="f95b22e50db62dd7475e308390e1bbfc" args="(const std::string &amp;name, bool set_cookie_header)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#f95b22e50db62dd7475e308390e1bbfc">isCookieAttribute</a> (const std::string &amp;name, bool set_cookie_header)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="822abf338fe18ecd34729afcb1298498"></a><!-- doxytag: member="pion::net::HTTPParser::m_logger" ref="822abf338fe18ecd34729afcb1298498" args="" -->
<a class="el" href="structpion_1_1_pion_logger.html">PionLogger</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#822abf338fe18ecd34729afcb1298498">m_logger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">primary logging interface used by this class <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="44ee011c9597863056d2166c58d23fe8"></a><!-- doxytag: member="pion::net::HTTPParser::m_is_request" ref="44ee011c9597863056d2166c58d23fe8" args="" -->
const bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#44ee011c9597863056d2166c58d23fe8">m_is_request</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if the message is an HTTP request; false if it is an HTTP response <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e13ac336cf09a6897b589832ee6ab0da"></a><!-- doxytag: member="pion::net::HTTPParser::m_read_ptr" ref="e13ac336cf09a6897b589832ee6ab0da" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#e13ac336cf09a6897b589832ee6ab0da">m_read_ptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">points to the next character to be consumed in the read_buffer <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1819fb391a103b5fdffb81169e2ebb8e"></a><!-- doxytag: member="pion::net::HTTPParser::m_read_end_ptr" ref="1819fb391a103b5fdffb81169e2ebb8e" args="" -->
const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#1819fb391a103b5fdffb81169e2ebb8e">m_read_end_ptr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">points to the end of the read_buffer (last byte + 1) <br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f549a3b6cd8828e6d952a7e19801480f"></a><!-- doxytag: member="pion::net::HTTPParser::STATUS_MESSAGE_MAX" ref="f549a3b6cd8828e6d952a7e19801480f" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#f549a3b6cd8828e6d952a7e19801480f">STATUS_MESSAGE_MAX</a> = 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for response status message <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa38a114f37ff980ec58f9da5c50b5db"></a><!-- doxytag: member="pion::net::HTTPParser::METHOD_MAX" ref="fa38a114f37ff980ec58f9da5c50b5db" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#fa38a114f37ff980ec58f9da5c50b5db">METHOD_MAX</a> = 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the request method <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4add415e3479ba4ffcfa4f3eeda356fa"></a><!-- doxytag: member="pion::net::HTTPParser::RESOURCE_MAX" ref="4add415e3479ba4ffcfa4f3eeda356fa" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#4add415e3479ba4ffcfa4f3eeda356fa">RESOURCE_MAX</a> = 256 * 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the resource requested <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="672c8779fee025dcde92569b6db010f1"></a><!-- doxytag: member="pion::net::HTTPParser::QUERY_STRING_MAX" ref="672c8779fee025dcde92569b6db010f1" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#672c8779fee025dcde92569b6db010f1">QUERY_STRING_MAX</a> = 1024 * 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the query string <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96da76034e15629e0f6e288ba288b406"></a><!-- doxytag: member="pion::net::HTTPParser::HEADER_NAME_MAX" ref="96da76034e15629e0f6e288ba288b406" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#96da76034e15629e0f6e288ba288b406">HEADER_NAME_MAX</a> = 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for an HTTP header name <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7654ef1a379b7854c2d0490371733fbb"></a><!-- doxytag: member="pion::net::HTTPParser::HEADER_VALUE_MAX" ref="7654ef1a379b7854c2d0490371733fbb" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#7654ef1a379b7854c2d0490371733fbb">HEADER_VALUE_MAX</a> = 1024 * 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for an HTTP header value <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0efa7c97831f9710d39adafdcf9edb02"></a><!-- doxytag: member="pion::net::HTTPParser::QUERY_NAME_MAX" ref="0efa7c97831f9710d39adafdcf9edb02" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#0efa7c97831f9710d39adafdcf9edb02">QUERY_NAME_MAX</a> = 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the name of a query string variable <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a671410687470793ee9ece4e0e2be7a"></a><!-- doxytag: member="pion::net::HTTPParser::QUERY_VALUE_MAX" ref="2a671410687470793ee9ece4e0e2be7a" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#2a671410687470793ee9ece4e0e2be7a">QUERY_VALUE_MAX</a> = 1024 * 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the value of a query string variable <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="acbdfeff150fc619bb43c82837a95a46"></a><!-- doxytag: member="pion::net::HTTPParser::COOKIE_NAME_MAX" ref="acbdfeff150fc619bb43c82837a95a46" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#acbdfeff150fc619bb43c82837a95a46">COOKIE_NAME_MAX</a> = 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the name of a cookie name <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7d9f1a3615cb1546eb571be4bc2055cc"></a><!-- doxytag: member="pion::net::HTTPParser::COOKIE_VALUE_MAX" ref="7d9f1a3615cb1546eb571be4bc2055cc" args="" -->
static const boost::uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#7d9f1a3615cb1546eb571be4bc2055cc">COOKIE_VALUE_MAX</a> = 1024 * 1024</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum length for the value of a cookie; also used for path and domain <br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="776a8378586ece49d07f954fe5c7f9cd"></a><!-- doxytag: member="pion::net::HTTPParser::HTTPParser" ref="776a8378586ece49d07f954fe5c7f9cd" args="(const bool is_request, std::size_t max_content_length=DEFAULT_CONTENT_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pion::net::HTTPParser::HTTPParser           </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>is_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>max_content_length</em> = <code><a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#e50d68030598ba2a9f8475179edbf398">DEFAULT_CONTENT_MAX</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
creates new <a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html">HTTPParser</a> objects<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>is_request</em>&nbsp;</td><td>if true, the message is parsed as an HTTP request; if false, the message is parsed as an HTTP response </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_content_length</em>&nbsp;</td><td>maximum length for HTTP payload content </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00047">47</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="285653cf89377a547dbefb452831fcf1"></a><!-- doxytag: member="pion::net::HTTPParser::checkPrematureEOF" ref="285653cf89377a547dbefb452831fcf1" args="(HTTPMessage &amp;http_msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pion::net::HTTPParser::checkPrematureEOF           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
checks to see if a premature EOF was encountered while parsing. This should be called if there is no more data to parse, and if the last call to the <a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#450e7a7a4c84afdfea735e45871fdfc1">parse()</a> function returned boost::indeterminate<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_mhttp://start.fedoraproject.org/sg</em>&nbsp;</td><td>the HTTP message object being parsed </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if premature EOF, false if message is OK &amp; finished parsing </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00123">123</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.
<p>
References <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00135">pion::net::HTTPMessage::concatenateChunks()</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00045">pion::net::HTTPMessage::receive()</a>.
</div>
</div><p>
<a class="anchor" name="1bd923adaa4867eccc6591d8137c0b9d"></a><!-- doxytag: member="pion::net::HTTPParser::computeMsgStatus" ref="1bd923adaa4867eccc6591d8137c0b9d" args="(HTTPMessage &amp;http_msg, bool msg_parsed_ok)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::net::HTTPParser::computeMsgStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>msg_parsed_ok</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
compute and sets a HTTP Message data integrity status <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>target HTTP message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_parsed_ok</em>&nbsp;</td><td>message parsing result </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01097">1097</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00257">pion::net::HTTPMessage::hasDataAfterMissingPackets()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00251">pion::net::HTTPMessage::hasMissingPackets()</a>, and <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00292">pion::net::HTTPMessage::setStatus()</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01046">finish()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>, and <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00111">parseMissingData()</a>.
</div>
</div><p>
<a class="anchor" name="9fa69e3cd5d84098734c48b31c4149e4"></a><!-- doxytag: member="pion::net::HTTPParser::consumeContent" ref="9fa69e3cd5d84098734c48b31c4149e4" args="(HTTPMessage &amp;http_msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tribool pion::net::HTTPParser::consumeContent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
consumes payload content in the parser's read buffer<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to consume content for</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boost::tribool result of parsing: false = message has an error, true = finished parsing message, indeterminate = message is not yet finished </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00987">987</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00150">bytes_available()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00185">pion::net::HTTPMessage::getContent()</a>, and <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00384">m_read_ptr</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>.
</div>
</div><p>
<a class="anchor" name="5e8a3afc3ab4a7ec7d54e972f539d1d2"></a><!-- doxytag: member="pion::net::HTTPParser::consumeContentAsNextChunk" ref="5e8a3afc3ab4a7ec7d54e972f539d1d2" args="(HTTPMessage::ChunkCache &amp;chunk_buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t pion::net::HTTPParser::consumeContentAsNextChunk           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html#3f51e42afcccf433e7992b55b9797d13">HTTPMessage::ChunkCache</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>chunk_buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
consume the bytes available in the read buffer, converting them into the next chunk for the HTTP message<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chunk_buffers</em>&nbsp;</td><td>buffers to be populated from parsing chunked content </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>std::size_t number of content bytes consumed, if any </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01029">1029</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00150">bytes_available()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00387">m_read_end_ptr</a>, and <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00384">m_read_ptr</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>.
</div>
</div><p>
<a class="anchor" name="b64c3586c434f51057ac320a96cfacf4"></a><!-- doxytag: member="pion::net::HTTPParser::contentTypeIsUrlEncoded" ref="b64c3586c434f51057ac320a96cfacf4" args="(HTTPRequest &amp;http_request)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool pion::net::HTTPParser::contentTypeIsUrlEncoded           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_request.html">HTTPRequest</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_request</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine if the Content-Type header is valid and has type "application/x-www-form-urlencoded", and if a charset parameter is found, save the value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_request</em>&nbsp;</td><td>request whose Content-Type header is being analyzed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>bool true if header is valid and has type "application/x-www-form-urlencoded" </dd></dl>

</div>
</div><p>
<a class="anchor" name="83fc56eb643b4afdae3b566d5e68220d"></a><!-- doxytag: member="pion::net::HTTPParser::finish" ref="83fc56eb643b4afdae3b566d5e68220d" args="(HTTPMessage &amp;http_msg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::net::HTTPParser::finish           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
finishes parsing an HTTP response message<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to finish </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01046">1046</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01097">computeMsgStatus()</a>, <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00135">pion::net::HTTPMessage::concatenateChunks()</a>, <a class="el" href="_h_t_t_p_types_8hpp-source.html#l00058">pion::net::HTTPTypes::CONTENT_TYPE_URLENCODED</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00319">pion::net::HTTPMessage::createContentBuffer()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00185">pion::net::HTTPMessage::getContent()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00159">getContentBytesRead()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00179">pion::net::HTTPMessage::getContentLength()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00194">pion::net::HTTPMessage::getHeader()</a>, <a class="el" href="_h_t_t_p_request_8hpp-source.html#l00077">pion::net::HTTPRequest::getQueryParams()</a>, <a class="el" href="_h_t_t_p_types_8hpp-source.html#l00040">pion::net::HTTPTypes::HEADER_CONTENT_TYPE</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00171">isParsingRequest()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00153">pion::net::HTTPMessage::isValid()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00378">m_logger</a>, <a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#cb14285ae8bfbf8e2f026afc3906e77a">parseURLEncoded()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00283">pion::net::HTTPMessage::setContentLength()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00262">pion::net::HTTPMessage::setIsValid()</a>, and <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00545">updateMessageWithHeaderData()</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>, and <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00111">parseMissingData()</a>.
</div>
</div><p>
<a class="anchor" name="590be730e45ea17b7facd8e36bc6b913"></a><!-- doxytag: member="pion::net::HTTPParser::finishHeaderParsing" ref="590be730e45ea17b7facd8e36bc6b913" args="(HTTPMessage &amp;http_msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tribool pion::net::HTTPParser::finishHeaderParsing           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
should be called after parsing HTTP headers, to prepare for payload content parsing available in the read buffer<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to populate from parsing</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boost::tribool result of parsing: false = message has an error, true = finished parsing HTTP message (no content), indeterminate = payload content is available to be parsed </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00600">600</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00319">pion::net::HTTPMessage::createContentBuffer()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00191">pion::net::HTTPMessage::getChunkCache()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00179">pion::net::HTTPMessage::getContentLength()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00204">pion::net::HTTPMessage::hasHeader()</a>, <a class="el" href="_h_t_t_p_types_8hpp-source.html#l00041">pion::net::HTTPTypes::HEADER_CONTENT_LENGTH</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00182">pion::net::HTTPMessage::isChunked()</a>, <a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html#2e1f11b807fea5467fed3b0b5bac1956">pion::net::HTTPMessage::isContentLengthImplied()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00381">m_is_request</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00378">m_logger</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00283">pion::net::HTTPMessage::setContentLength()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00295">pion::net::HTTPMessage::updateContentLengthUsingHeader()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00545">updateMessageWithHeaderData()</a>, and <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00307">pion::net::HTTPMessage::updateTransferCodingUsingHeader()</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>.
</div>
</div><p>
<a class="anchor" name="7e465ebe75416fa00586f1238e73c03b"></a><!-- doxytag: member="pion::net::HTTPParser::loadReadPosition" ref="7e465ebe75416fa00586f1238e73c03b" args="(const char *&amp;read_ptr, const char *&amp;read_end_ptr) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::net::HTTPParser::loadReadPosition           </td>
          <td>(</td>
          <td class="paramtype">const char *&amp;&nbsp;</td>
          <td class="paramname"> <em>read_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;&nbsp;</td>
          <td class="paramname"> <em>read_end_ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
loads a read position bookmark<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>read_ptr</em>&nbsp;</td><td>points to the next character to be consumed in the read_buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>read_end_ptr</em>&nbsp;</td><td>points to the end of the read_buffer (last byte + 1) </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00109">109</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00045">pion::net::HTTPMessage::receive()</a>.
</div>
</div><p>
<a class="anchor" name="450e7a7a4c84afdfea735e45871fdfc1"></a><!-- doxytag: member="pion::net::HTTPParser::parse" ref="450e7a7a4c84afdfea735e45871fdfc1" args="(HTTPMessage &amp;http_msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tribool pion::net::HTTPParser::parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses an HTTP message including all payload content it might contain<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to populate from parsing</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boost::tribool result of parsing: false = message has an error, true = finished parsing HTTP message, indeterminate = not yet finished parsing HTTP message </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">39</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01097">computeMsgStatus()</a>, <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00135">pion::net::HTTPMessage::concatenateChunks()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00987">consumeContent()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01029">consumeContentAsNextChunk()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00147">eof()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01046">finish()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00600">finishHeaderParsing()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00191">pion::net::HTTPMessage::getChunkCache()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00251">pion::net::HTTPMessage::hasMissingPackets()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00856">parseChunks()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00207">parseHeaders()</a>, and <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00259">pion::net::HTTPMessage::setDataAfterMissingPacket()</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_reader_8cpp-source.html#l00066">pion::net::HTTPReader::consumeBytes()</a>, and <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00045">pion::net::HTTPMessage::receive()</a>.
</div>
</div><p>
<a class="anchor" name="68070cc190f935ffddd6be3d149988da"></a><!-- doxytag: member="pion::net::HTTPParser::parseChunks" ref="68070cc190f935ffddd6be3d149988da" args="(HTTPMessage::ChunkCache &amp;chunk_buffers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tribool pion::net::HTTPParser::parseChunks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html#3f51e42afcccf433e7992b55b9797d13">HTTPMessage::ChunkCache</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>chunk_buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses a chunked HTTP message-body using bytes available in the read buffer<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chunk_buffers</em>&nbsp;</td><td>buffers to be populated from parsing chunked content</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boost::tribool result of parsing: false = message has an error, true = finished parsing message, indeterminate = message is not yet finished </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00856">856</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00517">isHexDigit()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00378">m_logger</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00387">m_read_end_ptr</a>, and <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00384">m_read_ptr</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>.
</div>
</div><p>
<a class="anchor" name="dffe57bbd26bf724ff0fb712504cf3b4"></a><!-- doxytag: member="pion::net::HTTPParser::parseCookieHeader" ref="dffe57bbd26bf724ff0fb712504cf3b4" args="(HTTPTypes::CookieParams &amp;dict, const std::string &amp;cookie_header, bool set_cookie_header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool pion::net::HTTPParser::parseCookieHeader           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#50fb5b59b0a6ad3eab753800cf78f4fb">HTTPTypes::CookieParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>cookie_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set_cookie_header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parse key-value pairs out of a "Cookie" request header (i.e. this=that; a=value)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>dictionary for key-values pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie_header</em>&nbsp;</td><td>header string to be parsed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_cookie_header</em>&nbsp;</td><td>set true if parsing Set-Cookie response header</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>bool true if successful </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00240">240</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.
</div>
</div><p>
<a class="anchor" name="385cb266ce38ce7709049fcd0af085c2"></a><!-- doxytag: member="pion::net::HTTPParser::parseCookieHeader" ref="385cb266ce38ce7709049fcd0af085c2" args="(HTTPTypes::CookieParams &amp;dict, const char *ptr, const std::size_t len, bool set_cookie_header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool pion::net::HTTPParser::parseCookieHeader           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#50fb5b59b0a6ad3eab753800cf78f4fb">HTTPTypes::CookieParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>set_cookie_header</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parse key-value pairs out of a "Cookie" request header (i.e. this=that; a=value)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>dictionary for key-values pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>points to the start of the header string to be parsed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the encoded string, in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>set_cookie_header</em>&nbsp;</td><td>set true if parsing Set-Cookie response header</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>bool true if successful </dd></dl>

<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00545">updateMessageWithHeaderData()</a>.
</div>
</div><p>
<a class="anchor" name="71858af1a78971cca63764900e4b255e"></a><!-- doxytag: member="pion::net::HTTPParser::parseHeaders" ref="71858af1a78971cca63764900e4b255e" args="(HTTPMessage &amp;http_msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tribool pion::net::HTTPParser::parseHeaders           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parses an HTTP message up to the end of the headers using bytes available in the read buffer<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to populate from parsing</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boost::tribool result of parsing: false = message has an error, true = finished parsing HTTP headers, indeterminate = not yet finished parsing HTTP headers </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00207">207</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00331">pion::net::HTTPMessage::addHeader()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00164">pion::net::HTTPMessage::getVersionMajor()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00167">pion::net::HTTPMessage::getVersionMinor()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00359">HEADER_NAME_MAX</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00362">HEADER_VALUE_MAX</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00489">isChar()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00494">isControl()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00512">isDigit()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00499">isSpecial()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00381">m_is_request</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00387">m_read_end_ptr</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00384">m_read_ptr</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00350">METHOD_MAX</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00356">QUERY_STRING_MAX</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00353">RESOURCE_MAX</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00271">pion::net::HTTPMessage::setVersionMajor()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00277">pion::net::HTTPMessage::setVersionMinor()</a>, and <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00347">STATUS_MESSAGE_MAX</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00039">parse()</a>.
</div>
</div><p>
<a class="anchor" name="a6bd7d9a08d575a88aec8b91d65cbe83"></a><!-- doxytag: member="pion::net::HTTPParser::parseMissingData" ref="a6bd7d9a08d575a88aec8b91d65cbe83" args="(HTTPMessage &amp;http_msg, std::size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tribool pion::net::HTTPParser::parseMissingData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
attempts to continue parsing despite having missed data (length is known but content is not)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to populate from parsing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length in bytes of the missing data</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>boost::tribool result of parsing: false = message has an error, true = finished parsing HTTP message, indeterminate = not yet finished parsing HTTP message </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00111">111</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01097">computeMsgStatus()</a>, <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01046">finish()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00191">pion::net::HTTPMessage::getChunkCache()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00185">pion::net::HTTPMessage::getContent()</a>, and <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00254">pion::net::HTTPMessage::setMissingPackets()</a>.
</div>
</div><p>
<a class="anchor" name="6c98f37d882e62417ba3032e4673c2fd"></a><!-- doxytag: member="pion::net::HTTPParser::parseURLEncoded" ref="6c98f37d882e62417ba3032e4673c2fd" args="(HTTPTypes::QueryParams &amp;dict, const std::string &amp;query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool pion::net::HTTPParser::parseURLEncoded           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#5dbaae025e754a4862957d17e2e7d9cf">HTTPTypes::QueryParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>query</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parse key-value pairs out of a url-encoded string (i.e. this=that&amp;a=value)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>dictionary for key-values pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>query</em>&nbsp;</td><td>the encoded query string to be parsed</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>bool true if successful </dd></dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00255">255</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.
</div>
</div><p>
<a class="anchor" name="cb14285ae8bfbf8e2f026afc3906e77a"></a><!-- doxytag: member="pion::net::HTTPParser::parseURLEncoded" ref="cb14285ae8bfbf8e2f026afc3906e77a" args="(HTTPTypes::QueryParams &amp;dict, const char *ptr, const std::size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool pion::net::HTTPParser::parseURLEncoded           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpion_1_1net_1_1_h_t_t_p_types.html#5dbaae025e754a4862957d17e2e7d9cf">HTTPTypes::QueryParams</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
parse key-value pairs out of a url-encoded string (i.e. this=that&amp;a=value)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dict</em>&nbsp;</td><td>dictionary for key-values pairs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>points to the start of the encoded string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the encoded string, in bytes</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>bool true if successful </dd></dl>

<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01046">finish()</a>, and <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00545">updateMessageWithHeaderData()</a>.
</div>
</div><p>
<a class="anchor" name="24023fdadcccbf6deb536055a30f6cf0"></a><!-- doxytag: member="pion::net::HTTPParser::setReadBuffer" ref="24023fdadcccbf6deb536055a30f6cf0" args="(const char *ptr, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::net::HTTPParser::setReadBuffer           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
resets the location and size of the read buffer<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to the first bytes available to be read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>number of bytes available to be read </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00098">98</a> of file <a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_reader_8cpp-source.html#l00041">pion::net::HTTPReader::consumeBytes()</a>, and <a class="el" href="_h_t_t_p_message_8cpp-source.html#l00045">pion::net::HTTPMessage::receive()</a>.
</div>
</div><p>
<a class="anchor" name="c6211a4748e0480ddc765cbf89b8deb8"></a><!-- doxytag: member="pion::net::HTTPParser::updateMessageWithHeaderData" ref="c6211a4748e0480ddc765cbf89b8deb8" args="(HTTPMessage &amp;http_msg) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pion::net::HTTPParser::updateMessageWithHeaderData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>http_msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
updates an <a class="el" href="classpion_1_1net_1_1_h_t_t_p_message.html">HTTPMessage</a> object with data obtained from parsing headers<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>http_msg</em>&nbsp;</td><td>the HTTP message object to populate from parsing </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00545">545</a> of file <a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a>.
<p>
References <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00215">pion::net::HTTPMessage::getCookieParams()</a>, <a class="el" href="_h_t_t_p_message_8hpp-source.html#l00199">pion::net::HTTPMessage::getHeaders()</a>, <a class="el" href="_h_t_t_p_request_8hpp-source.html#l00077">pion::net::HTTPRequest::getQueryParams()</a>, <a class="el" href="_h_t_t_p_types_8hpp-source.html#l00037">pion::net::HTTPTypes::HEADER_COOKIE</a>, <a class="el" href="_h_t_t_p_types_8hpp-source.html#l00038">pion::net::HTTPTypes::HEADER_SET_COOKIE</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00171">isParsingRequest()</a>, <a class="el" href="_h_t_t_p_parser_8hpp-source.html#l00378">m_logger</a>, <a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#385cb266ce38ce7709049fcd0af085c2">parseCookieHeader()</a>, <a class="el" href="classpion_1_1net_1_1_h_t_t_p_parser.html#cb14285ae8bfbf8e2f026afc3906e77a">parseURLEncoded()</a>, <a class="el" href="_h_t_t_p_request_8hpp-source.html#l00087">pion::net::HTTPRequest::setMethod()</a>, <a class="el" href="_h_t_t_p_request_8hpp-source.html#l00102">pion::net::HTTPRequest::setQueryString()</a>, <a class="el" href="_h_t_t_p_request_8hpp-source.html#l00093">pion::net::HTTPRequest::setResource()</a>, <a class="el" href="_h_t_t_p_response_8hpp-source.html#l00102">pion::net::HTTPResponse::setStatusCode()</a>, and <a class="el" href="_h_t_t_p_response_8hpp-source.html#l00108">pion::net::HTTPResponse::setStatusMessage()</a>.
<p>
Referenced by <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l01046">finish()</a>, and <a class="el" href="_h_t_t_p_parser_8cpp-source.html#l00600">finishHeaderParsing()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>net/include/pion/net/<a class="el" href="_h_t_t_p_parser_8hpp-source.html">HTTPParser.hpp</a><li>net/src/<a class="el" href="_h_t_t_p_parser_8cpp-source.html">HTTPParser.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue Aug 10 15:23:13 2010 for pion-net by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
