<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pion-net: net/include/pion/net/TCPStream.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>net/include/pion/net/TCPStream.hpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// ------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment">// pion-net: a C++ framework for building lightweight HTTP interfaces</span>
<a name="l00003"></a>00003 <span class="comment">// ------------------------------------------------------------------</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (C) 2007-2008 Atomic Labs, Inc.  (http://www.atomiclabs.com)</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/LICENSE_1_0.txt</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef __PION_TCPSTREAM_HEADER__</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define __PION_TCPSTREAM_HEADER__</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;istream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;streambuf&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;boost/thread/mutex.hpp&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;boost/thread/condition.hpp&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;pion/PionConfig.hpp&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;pion/net/TCPConnection.hpp&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="keyword">namespace </span>pion {    <span class="comment">// begin namespace pion</span>
<a name="l00024"></a>00024 <span class="keyword">namespace </span>net {     <span class="comment">// begin namespace net (Pion Network Library)</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026     
<a name="l00032"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html">00032</a> <span class="keyword">class </span><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html">TCPStreamBuffer</a>
<a name="l00033"></a>00033     : <span class="keyword">public</span> std::basic_streambuf&lt;char, std::char_traits&lt;char&gt; &gt;
<a name="l00034"></a>00034 {
<a name="l00035"></a>00035 <span class="keyword">public</span>:
<a name="l00036"></a>00036     
<a name="l00037"></a>00037     <span class="comment">// data type definitions required for iostream compatability</span>
<a name="l00038"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#4e00c92af5fb7d3d2c42c1764623925f">00038</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>                                <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#4e00c92af5fb7d3d2c42c1764623925f">char_type</a>;
<a name="l00039"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">00039</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;::int_type    <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a>;
<a name="l00040"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#870c16af217f8a796d7dd839e53173d7">00040</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;::off_type    <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#870c16af217f8a796d7dd839e53173d7">off_type</a>;
<a name="l00041"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#12d5f8242dfe66f20f4cb48ba102dcc5">00041</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;::pos_type    <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#12d5f8242dfe66f20f4cb48ba102dcc5">pos_type</a>;
<a name="l00042"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#9ddaa212cd1851efa707202fff907a81">00042</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;              <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#9ddaa212cd1851efa707202fff907a81">traits_type</a>;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044     <span class="comment">// some integer constants used within TCPStreamBuffer</span>
<a name="l00045"></a>00045     <span class="keyword">enum</span> {
<a name="l00046"></a>00046         PUT_BACK_MAX = 10,  <span class="comment">//&lt; number of bytes that can be put back into the read buffer</span>
<a name="l00047"></a>00047         WRITE_BUFFER_SIZE = 8192    <span class="comment">//&lt; size of the write buffer</span>
<a name="l00048"></a>00048     };
<a name="l00049"></a>00049     
<a name="l00050"></a>00050     
<a name="l00056"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#7a422f167860926c9953a3d902ab2d12">00056</a>     <span class="keyword">explicit</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#7a422f167860926c9953a3d902ab2d12">TCPStreamBuffer</a>(<a class="code" href="namespacepion_1_1net.html#e66ec40cd9d138619b1142311e8fee59">TCPConnectionPtr</a>&amp; conn_ptr)
<a name="l00057"></a>00057         : m_conn_ptr(conn_ptr), m_read_buf(m_conn_ptr-&gt;getReadBuffer().c_array())
<a name="l00058"></a>00058     {
<a name="l00059"></a>00059         <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#37e77fee4d43bd0ee76edd0e15821f97">setupBuffers</a>();
<a name="l00060"></a>00060     }
<a name="l00061"></a>00061 
<a name="l00068"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#9661c09526d9fd0a07f6197b71500d5f">00068</a>     <span class="keyword">explicit</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#7a422f167860926c9953a3d902ab2d12">TCPStreamBuffer</a>(boost::asio::io_service&amp; io_service,
<a name="l00069"></a>00069                              <span class="keyword">const</span> <span class="keywordtype">bool</span> ssl_flag = <span class="keyword">false</span>)
<a name="l00070"></a>00070         : m_conn_ptr(new <a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html">TCPConnection</a>(io_service, ssl_flag)),
<a name="l00071"></a>00071         m_read_buf(m_conn_ptr-&gt;getReadBuffer().c_array())
<a name="l00072"></a>00072     {
<a name="l00073"></a>00073         <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#37e77fee4d43bd0ee76edd0e15821f97">setupBuffers</a>();
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075     
<a name="l00082"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#8ff8b1e8603339d436b93b9f8b8d8c85">00082</a>     <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#7a422f167860926c9953a3d902ab2d12">TCPStreamBuffer</a>(boost::asio::io_service&amp; io_service,
<a name="l00083"></a>00083                     <a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#23549697333e2a4363696d8bfe3af5fe">TCPConnection::SSLContext</a>&amp; ssl_context)
<a name="l00084"></a>00084         : m_conn_ptr(new <a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html">TCPConnection</a>(io_service, ssl_context)),
<a name="l00085"></a>00085         m_read_buf(m_conn_ptr-&gt;getReadBuffer().c_array())
<a name="l00086"></a>00086     {
<a name="l00087"></a>00087         <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#37e77fee4d43bd0ee76edd0e15821f97">setupBuffers</a>();
<a name="l00088"></a>00088     }
<a name="l00089"></a>00089     
<a name="l00091"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#da1d3ec1b69ec0dac0258fd8f5f42e58">00091</a>     <span class="keyword">virtual</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#da1d3ec1b69ec0dac0258fd8f5f42e58">~TCPStreamBuffer</a>() { <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#cffdc42361a699fd7dfce0bd9fcd90c6">sync</a>(); }
<a name="l00092"></a>00092 
<a name="l00094"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">00094</a>     <a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html">TCPConnection</a>&amp; <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> *m_conn_ptr; }
<a name="l00095"></a>00095 
<a name="l00097"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#f78c744dacd9953cf0601af098b53bee">00097</a>     <span class="keyword">const</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html">TCPConnection</a>&amp; <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *m_conn_ptr; }
<a name="l00098"></a>00098     
<a name="l00099"></a>00099     
<a name="l00100"></a>00100 <span class="keyword">protected</span>:
<a name="l00101"></a>00101 
<a name="l00103"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#37e77fee4d43bd0ee76edd0e15821f97">00103</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#37e77fee4d43bd0ee76edd0e15821f97">setupBuffers</a>(<span class="keywordtype">void</span>) {
<a name="l00104"></a>00104         <span class="comment">// use the TCP connection's read buffer and allow for bytes to be put back</span>
<a name="l00105"></a>00105         setg(m_read_buf+PUT_BACK_MAX, m_read_buf+PUT_BACK_MAX, m_read_buf+PUT_BACK_MAX);
<a name="l00106"></a>00106         <span class="comment">// set write buffer size-1 so that we have an extra char avail for overflow</span>
<a name="l00107"></a>00107         setp(m_write_buf, m_write_buf+(WRITE_BUFFER_SIZE-1));
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109     
<a name="l00115"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ff6b021d2c386583372f97936d38f749">00115</a>     <span class="keyword">inline</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ff6b021d2c386583372f97936d38f749">flushOutput</a>(<span class="keywordtype">void</span>) {
<a name="l00116"></a>00116         <span class="keyword">const</span> std::streamsize bytes_to_send = std::streamsize(pptr() - pbase());
<a name="l00117"></a>00117         <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a> bytes_sent = 0;
<a name="l00118"></a>00118         <span class="keywordflow">if</span> (bytes_to_send &gt; 0) {
<a name="l00119"></a>00119             boost::mutex::scoped_lock async_lock(m_async_mutex);
<a name="l00120"></a>00120             m_bytes_transferred = 0;
<a name="l00121"></a>00121             m_conn_ptr-&gt;async_write(boost::asio::buffer(pbase(), bytes_to_send),
<a name="l00122"></a>00122                                     boost::bind(&amp;TCPStreamBuffer::operationFinished, <span class="keyword">this</span>,
<a name="l00123"></a>00123                                                 boost::asio::placeholders::error,
<a name="l00124"></a>00124                                                 boost::asio::placeholders::bytes_transferred));
<a name="l00125"></a>00125             m_async_done.wait(async_lock);
<a name="l00126"></a>00126             bytes_sent = m_bytes_transferred;
<a name="l00127"></a>00127             pbump(-bytes_sent);
<a name="l00128"></a>00128             <span class="keywordflow">if</span> (m_async_error)
<a name="l00129"></a>00129                 bytes_sent = traits_type::eof();
<a name="l00130"></a>00130         }
<a name="l00131"></a>00131         <span class="keywordflow">return</span> bytes_sent;
<a name="l00132"></a>00132     }
<a name="l00133"></a>00133     
<a name="l00139"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ab911ff25138f9655f15624d1dc1ccc9">00139</a>     <span class="keyword">virtual</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ab911ff25138f9655f15624d1dc1ccc9">underflow</a>(<span class="keywordtype">void</span>) {
<a name="l00140"></a>00140         <span class="comment">// first check if we still have bytes available in the read buffer</span>
<a name="l00141"></a>00141         <span class="keywordflow">if</span> (gptr() &lt; egptr())
<a name="l00142"></a>00142             <span class="keywordflow">return</span> traits_type::to_int_type(*gptr());
<a name="l00143"></a>00143         
<a name="l00144"></a>00144         <span class="comment">// calculate the number of bytes we will allow to be put back</span>
<a name="l00145"></a>00145         std::streamsize put_back_num = std::streamsize(gptr() - eback());
<a name="l00146"></a>00146         <span class="keywordflow">if</span> (put_back_num &gt; PUT_BACK_MAX)
<a name="l00147"></a>00147             put_back_num = PUT_BACK_MAX;
<a name="l00148"></a>00148         
<a name="l00149"></a>00149         <span class="comment">// copy the last bytes read to the beginning of the buffer (for put back)</span>
<a name="l00150"></a>00150         <span class="keywordflow">if</span> (put_back_num &gt; 0)
<a name="l00151"></a>00151             memmove(m_read_buf+(PUT_BACK_MAX-put_back_num), gptr()-put_back_num, put_back_num);
<a name="l00152"></a>00152         
<a name="l00153"></a>00153         <span class="comment">// read data from the TCP connection</span>
<a name="l00154"></a>00154         <span class="comment">// note that this has to be an ansynchronous call; otherwise, it cannot</span>
<a name="l00155"></a>00155         <span class="comment">// be cancelled by other threads and will block forever (such as during shutdown)</span>
<a name="l00156"></a>00156         boost::mutex::scoped_lock async_lock(m_async_mutex);
<a name="l00157"></a>00157         m_bytes_transferred = 0;
<a name="l00158"></a>00158         m_conn_ptr-&gt;async_read_some(boost::asio::buffer(m_read_buf+PUT_BACK_MAX,
<a name="l00159"></a>00159                                                         TCPConnection::READ_BUFFER_SIZE-PUT_BACK_MAX),
<a name="l00160"></a>00160                                     boost::bind(&amp;TCPStreamBuffer::operationFinished, <span class="keyword">this</span>,
<a name="l00161"></a>00161                                                 boost::asio::placeholders::error,
<a name="l00162"></a>00162                                                 boost::asio::placeholders::bytes_transferred));
<a name="l00163"></a>00163         m_async_done.wait(async_lock);
<a name="l00164"></a>00164         <span class="keywordflow">if</span> (m_async_error)
<a name="l00165"></a>00165             <span class="keywordflow">return</span> traits_type::eof();
<a name="l00166"></a>00166         
<a name="l00167"></a>00167         <span class="comment">// reset buffer pointers now that data is available</span>
<a name="l00168"></a>00168         setg(m_read_buf+(PUT_BACK_MAX-put_back_num),            <span class="comment">//&lt; beginning of putback bytes</span>
<a name="l00169"></a>00169              m_read_buf+PUT_BACK_MAX,                           <span class="comment">//&lt; read position</span>
<a name="l00170"></a>00170              m_read_buf+PUT_BACK_MAX+m_bytes_transferred);      <span class="comment">//&lt; end of buffer</span>
<a name="l00171"></a>00171         
<a name="l00172"></a>00172         <span class="comment">// return next character available</span>
<a name="l00173"></a>00173         <span class="keywordflow">return</span> traits_type::to_int_type(*gptr());
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00182"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#b377e0158f899ac8830a3fd2ab0dbbb7">00182</a>     <span class="keyword">virtual</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#b377e0158f899ac8830a3fd2ab0dbbb7">overflow</a>(<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a> c) {
<a name="l00183"></a>00183         <span class="keywordflow">if</span> (! traits_type::eq_int_type(c, traits_type::eof())) {
<a name="l00184"></a>00184             <span class="comment">// character is not eof -&gt; add it to the end of the write buffer</span>
<a name="l00185"></a>00185             <span class="comment">// we can push this to the back of the write buffer because we set</span>
<a name="l00186"></a>00186             <span class="comment">// the size of the write buffer to 1 less than the actual size using setp()</span>
<a name="l00187"></a>00187             *pptr() = c;
<a name="l00188"></a>00188             pbump(1);
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190         <span class="comment">// flush data in the write buffer by sending it to the TCP connection</span>
<a name="l00191"></a>00191         <span class="keywordflow">return</span> ((<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ff6b021d2c386583372f97936d38f749">flushOutput</a>() == traits_type::eof())
<a name="l00192"></a>00192                 ? traits_type::eof() : traits_type::not_eof(c));
<a name="l00193"></a>00193     }
<a name="l00194"></a>00194 
<a name="l00203"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#24d5381820d07a7e700cf161861aebb0">00203</a>     <span class="keyword">virtual</span> std::streamsize <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#24d5381820d07a7e700cf161861aebb0">xsputn</a>(<span class="keyword">const</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#4e00c92af5fb7d3d2c42c1764623925f">char_type</a> *s, std::streamsize n) {
<a name="l00204"></a>00204         <span class="keyword">const</span> std::streamsize bytes_available = std::streamsize(epptr() - pptr());
<a name="l00205"></a>00205         std::streamsize bytes_sent = 0;
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (bytes_available &gt;= n) {
<a name="l00207"></a>00207             <span class="comment">// there is enough room in the buffer -&gt; just put it in there</span>
<a name="l00208"></a>00208             memcpy(pptr(), s, n);
<a name="l00209"></a>00209             pbump(n);
<a name="l00210"></a>00210             bytes_sent = n;
<a name="l00211"></a>00211         } <span class="keywordflow">else</span> {
<a name="l00212"></a>00212             <span class="comment">// there is not enough room left in the buffer</span>
<a name="l00213"></a>00213             <span class="keywordflow">if</span> (bytes_available &gt; 0) {
<a name="l00214"></a>00214                 <span class="comment">// fill up the buffer</span>
<a name="l00215"></a>00215                 memcpy(pptr(), s, bytes_available);
<a name="l00216"></a>00216                 pbump(bytes_available);
<a name="l00217"></a>00217             }
<a name="l00218"></a>00218             <span class="comment">// flush data in the write buffer by sending it to the TCP connection</span>
<a name="l00219"></a>00219             <span class="keywordflow">if</span> (<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ff6b021d2c386583372f97936d38f749">flushOutput</a>() == traits_type::eof()) 
<a name="l00220"></a>00220                 <span class="keywordflow">return</span> 0;
<a name="l00221"></a>00221             <span class="keywordflow">if</span> ((n-bytes_available) &gt;= (WRITE_BUFFER_SIZE-1)) {
<a name="l00222"></a>00222                 <span class="comment">// the remaining data to send is larger than the buffer available</span>
<a name="l00223"></a>00223                 <span class="comment">// send it all now rather than buffering</span>
<a name="l00224"></a>00224                 boost::mutex::scoped_lock async_lock(m_async_mutex);
<a name="l00225"></a>00225                 m_bytes_transferred = 0;
<a name="l00226"></a>00226                 m_conn_ptr-&gt;async_write(boost::asio::buffer(s+bytes_available,
<a name="l00227"></a>00227                                                             n-bytes_available),
<a name="l00228"></a>00228                                         boost::bind(&amp;TCPStreamBuffer::operationFinished, <span class="keyword">this</span>,
<a name="l00229"></a>00229                                                     boost::asio::placeholders::error,
<a name="l00230"></a>00230                                                     boost::asio::placeholders::bytes_transferred));
<a name="l00231"></a>00231                 m_async_done.wait(async_lock);
<a name="l00232"></a>00232                 bytes_sent = bytes_available + m_bytes_transferred;
<a name="l00233"></a>00233             } <span class="keywordflow">else</span> {
<a name="l00234"></a>00234                 <span class="comment">// the buffer is larger than the remaining data</span>
<a name="l00235"></a>00235                 <span class="comment">// put remaining data to the beginning of the output buffer</span>
<a name="l00236"></a>00236                 memcpy(pbase(), s+bytes_available, n-bytes_available);
<a name="l00237"></a>00237                 pbump(n-bytes_available);
<a name="l00238"></a>00238                 bytes_sent = n;
<a name="l00239"></a>00239             }
<a name="l00240"></a>00240         }
<a name="l00241"></a>00241         <span class="keywordflow">return</span> bytes_sent;
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243     
<a name="l00252"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#accda7cb8e74363323864b97e34b9363">00252</a>     <span class="keyword">virtual</span> std::streamsize <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#accda7cb8e74363323864b97e34b9363">xsgetn</a>(<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#4e00c92af5fb7d3d2c42c1764623925f">char_type</a> *s, std::streamsize n) {
<a name="l00253"></a>00253         std::streamsize bytes_remaining = n;
<a name="l00254"></a>00254         <span class="keywordflow">while</span> (bytes_remaining &gt; 0) {
<a name="l00255"></a>00255             <span class="keyword">const</span> std::streamsize bytes_available = std::streamsize(egptr() - gptr());
<a name="l00256"></a>00256             <span class="keyword">const</span> std::streamsize bytes_next_read = ((bytes_available &gt;= bytes_remaining)
<a name="l00257"></a>00257                                                    ? bytes_remaining : bytes_available);
<a name="l00258"></a>00258             <span class="comment">// copy available input data from buffer</span>
<a name="l00259"></a>00259             <span class="keywordflow">if</span> (bytes_next_read &gt; 0) {
<a name="l00260"></a>00260                 memcpy(s, gptr(), bytes_next_read);
<a name="l00261"></a>00261                 gbump(bytes_next_read);
<a name="l00262"></a>00262                 bytes_remaining -= bytes_next_read;
<a name="l00263"></a>00263                 s += bytes_next_read;
<a name="l00264"></a>00264             }
<a name="l00265"></a>00265             <span class="keywordflow">if</span> (bytes_remaining &gt; 0) {
<a name="l00266"></a>00266                 <span class="comment">// call underflow() to read more data</span>
<a name="l00267"></a>00267                 <span class="keywordflow">if</span> (traits_type::eq_int_type(<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ab911ff25138f9655f15624d1dc1ccc9">underflow</a>(), traits_type::eof()))
<a name="l00268"></a>00268                     <span class="keywordflow">break</span>;
<a name="l00269"></a>00269             }
<a name="l00270"></a>00270         }
<a name="l00271"></a>00271         <span class="keywordflow">return</span>(n-bytes_remaining);
<a name="l00272"></a>00272     }           
<a name="l00273"></a>00273         
<a name="l00279"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#cffdc42361a699fd7dfce0bd9fcd90c6">00279</a>     <span class="keyword">virtual</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#efca7b26caaa2dfb5944457bc2884f85">int_type</a> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#cffdc42361a699fd7dfce0bd9fcd90c6">sync</a>(<span class="keywordtype">void</span>) {
<a name="l00280"></a>00280         <span class="keywordflow">return</span> ((<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#ff6b021d2c386583372f97936d38f749">flushOutput</a>() == traits_type::eof()) ? -1 : 0);
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     
<a name="l00283"></a>00283     
<a name="l00284"></a>00284 <span class="keyword">private</span>:
<a name="l00285"></a>00285     
<a name="l00287"></a>00287     <span class="keyword">inline</span> <span class="keywordtype">void</span> operationFinished(<span class="keyword">const</span> boost::system::error_code&amp; error_code,
<a name="l00288"></a>00288                                   std::size_t bytes_transferred)
<a name="l00289"></a>00289     {
<a name="l00290"></a>00290         boost::mutex::scoped_lock async_lock(m_async_mutex);
<a name="l00291"></a>00291         m_async_error = error_code;
<a name="l00292"></a>00292         m_bytes_transferred = bytes_transferred;
<a name="l00293"></a>00293         m_async_done.notify_one();
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295     
<a name="l00296"></a>00296     
<a name="l00298"></a>00298     <a class="code" href="namespacepion_1_1net.html#e66ec40cd9d138619b1142311e8fee59">TCPConnectionPtr</a>            m_conn_ptr;
<a name="l00299"></a>00299     
<a name="l00301"></a>00301     boost::mutex                m_async_mutex;
<a name="l00302"></a>00302     
<a name="l00304"></a>00304     boost::condition            m_async_done;
<a name="l00305"></a>00305     
<a name="l00307"></a>00307     boost::system::error_code   m_async_error;
<a name="l00308"></a>00308     
<a name="l00310"></a>00310     std::size_t                 m_bytes_transferred;
<a name="l00311"></a>00311     
<a name="l00313"></a>00313     <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#4e00c92af5fb7d3d2c42c1764623925f">char_type</a> *                 m_read_buf;
<a name="l00314"></a>00314              
<a name="l00316"></a>00316     <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#4e00c92af5fb7d3d2c42c1764623925f">char_type</a>                   m_write_buf[WRITE_BUFFER_SIZE];
<a name="l00317"></a>00317 };
<a name="l00318"></a>00318     
<a name="l00319"></a>00319     
<a name="l00323"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html">00323</a> <span class="keyword">class </span><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html">TCPStream</a>
<a name="l00324"></a>00324     : <span class="keyword">public</span> std::basic_iostream&lt;char, std::char_traits&lt;char&gt; &gt;
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326 <span class="keyword">public</span>:
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     <span class="comment">// data type definitions required for iostream compatability</span>
<a name="l00329"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#539e454c329643c006e582eb5ece18f5">00329</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>                                <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#539e454c329643c006e582eb5ece18f5">char_type</a>;
<a name="l00330"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#001ac3555ea939e63a888215f2545f4d">00330</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;::int_type    <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#001ac3555ea939e63a888215f2545f4d">int_type</a>;
<a name="l00331"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#94baa021380c295e0f735326b1e95a90">00331</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;::off_type    <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#94baa021380c295e0f735326b1e95a90">off_type</a>;
<a name="l00332"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#4eeae85149e113b0e7f3c1ae33c5c8c8">00332</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;::pos_type    <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#4eeae85149e113b0e7f3c1ae33c5c8c8">pos_type</a>;
<a name="l00333"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#f766f48372e1a11a32c03f89f384d98a">00333</a>     <span class="keyword">typedef</span> std::char_traits&lt;char&gt;              <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#f766f48372e1a11a32c03f89f384d98a">traits_type</a>;
<a name="l00334"></a>00334     
<a name="l00335"></a>00335 
<a name="l00341"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#b7c7d8ade647175eaa062c5c73cf8419">00341</a>     <span class="keyword">explicit</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#b7c7d8ade647175eaa062c5c73cf8419">TCPStream</a>(<a class="code" href="namespacepion_1_1net.html#e66ec40cd9d138619b1142311e8fee59">TCPConnectionPtr</a>&amp; conn_ptr)
<a name="l00342"></a>00342         : m_tcp_buf(conn_ptr)
<a name="l00343"></a>00343 #ifdef _MSC_VER
<a name="l00344"></a>00344         , std::basic_iostream&lt;char, std::char_traits&lt;char&gt; &gt;(NULL)
<a name="l00345"></a>00345 #endif
<a name="l00346"></a>00346     {
<a name="l00347"></a>00347         <span class="comment">// initialize basic_iostream with pointer to the stream buffer</span>
<a name="l00348"></a>00348         std::basic_ios&lt;char,std::char_traits&lt;char&gt; &gt;::init(&amp;m_tcp_buf);
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350     
<a name="l00357"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#d4af444bc30e5b654a6a62fc011ee4a3">00357</a>     <span class="keyword">explicit</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#b7c7d8ade647175eaa062c5c73cf8419">TCPStream</a>(boost::asio::io_service&amp; io_service,
<a name="l00358"></a>00358                        <span class="keyword">const</span> <span class="keywordtype">bool</span> ssl_flag = <span class="keyword">false</span>)
<a name="l00359"></a>00359         : m_tcp_buf(io_service, ssl_flag)
<a name="l00360"></a>00360 #ifdef _MSC_VER
<a name="l00361"></a>00361         , std::basic_iostream&lt;char, std::char_traits&lt;char&gt; &gt;(NULL)
<a name="l00362"></a>00362 #endif
<a name="l00363"></a>00363     {
<a name="l00364"></a>00364         <span class="comment">// initialize basic_iostream with pointer to the stream buffer</span>
<a name="l00365"></a>00365         std::basic_ios&lt;char,std::char_traits&lt;char&gt; &gt;::init(&amp;m_tcp_buf);
<a name="l00366"></a>00366     }
<a name="l00367"></a>00367     
<a name="l00374"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#1c87ae30652cfac49c6e9316407b9297">00374</a>     <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#b7c7d8ade647175eaa062c5c73cf8419">TCPStream</a>(boost::asio::io_service&amp; io_service,
<a name="l00375"></a>00375               <a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#23549697333e2a4363696d8bfe3af5fe">TCPConnection::SSLContext</a>&amp; ssl_context)
<a name="l00376"></a>00376         : m_tcp_buf(io_service, ssl_context)
<a name="l00377"></a>00377 #ifdef _MSC_VER
<a name="l00378"></a>00378         , std::basic_iostream&lt;char, std::char_traits&lt;char&gt; &gt;(NULL)
<a name="l00379"></a>00379 #endif
<a name="l00380"></a>00380     {
<a name="l00381"></a>00381         <span class="comment">// initialize basic_iostream with pointer to the stream buffer</span>
<a name="l00382"></a>00382         std::basic_ios&lt;char,std::char_traits&lt;char&gt; &gt;::init(&amp;m_tcp_buf);
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384     
<a name="l00393"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#0751ad9a0d5b76f0f7c965b64674172f">00393</a>     <span class="keyword">inline</span> boost::system::error_code <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#0751ad9a0d5b76f0f7c965b64674172f">accept</a>(boost::asio::ip::tcp::acceptor&amp; tcp_acceptor)
<a name="l00394"></a>00394     {
<a name="l00395"></a>00395         boost::system::error_code ec = m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#45aea4515afd1672a7a1d21b41903194">accept</a>(tcp_acceptor);
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (! ec) ec = m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#f754333825719c0b8f42e3435a99493e">handshake_server</a>();
<a name="l00397"></a>00397         <span class="keywordflow">return</span> ec;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399 
<a name="l00408"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#aeb6a6e2c60befd33383796a3be17f19">00408</a>     <span class="keyword">inline</span> boost::system::error_code <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#aeb6a6e2c60befd33383796a3be17f19">connect</a>(boost::asio::ip::tcp::endpoint&amp; tcp_endpoint)
<a name="l00409"></a>00409     {
<a name="l00410"></a>00410         boost::system::error_code ec = m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#d9abf724fffc5d71e963ab5edc58c328">connect</a>(tcp_endpoint);
<a name="l00411"></a>00411         <span class="keywordflow">if</span> (! ec) ec = m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#92b0da25d9b5cfcf1316e114e8462113">handshake_client</a>();
<a name="l00412"></a>00412         <span class="keywordflow">return</span> ec;
<a name="l00413"></a>00413     }
<a name="l00414"></a>00414     
<a name="l00424"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#4731f296650a7c15d084485771b59e7c">00424</a>     <span class="keyword">inline</span> boost::system::error_code <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#aeb6a6e2c60befd33383796a3be17f19">connect</a>(<span class="keyword">const</span> boost::asio::ip::address&amp; remote_addr,
<a name="l00425"></a>00425                                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> remote_port)
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427         boost::asio::ip::tcp::endpoint tcp_endpoint(remote_addr, remote_port);
<a name="l00428"></a>00428         boost::system::error_code ec = m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#d9abf724fffc5d71e963ab5edc58c328">connect</a>(tcp_endpoint);
<a name="l00429"></a>00429         <span class="keywordflow">if</span> (! ec) ec = m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#92b0da25d9b5cfcf1316e114e8462113">handshake_client</a>();
<a name="l00430"></a>00430         <span class="keywordflow">return</span> ec;
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432 
<a name="l00434"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#0f246d4b81b22e41a0bdb9eaaca139a2">00434</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#0f246d4b81b22e41a0bdb9eaaca139a2">close</a>(<span class="keywordtype">void</span>) { m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#b342c955544dc37db056b426b1f0ad1e">close</a>(); }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436     <span class="comment">/*</span>
<a name="l00437"></a>00437 <span class="comment">    Use close instead; basic_socket::cancel is deprecated for Windows XP.</span>
<a name="l00438"></a>00438 <span class="comment"></span>
<a name="l00440"></a>00440 <span class="comment">    inline void cancel(void) { m_tcp_buf.getConnection().cancel(); }</span>
<a name="l00441"></a>00441 <span class="comment">    */</span>
<a name="l00442"></a>00442 
<a name="l00444"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#677dbc5f63de31abfde83079f4eba808">00444</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#677dbc5f63de31abfde83079f4eba808">is_open</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#a45fc44d455e5887b7498295fa48716b">is_open</a>(); }
<a name="l00445"></a>00445     
<a name="l00447"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#1001710f329f661a4c2028ecbe2accc5">00447</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#1001710f329f661a4c2028ecbe2accc5">getSSLFlag</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#ff6b0cd574bfc595cd65dfe04f4a64fb">getSSLFlag</a>(); }
<a name="l00448"></a>00448 
<a name="l00450"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#08d7079b431c12f7df5aea76b1ef0529">00450</a>     <span class="keyword">inline</span> boost::asio::ip::address <a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#08d7079b431c12f7df5aea76b1ef0529">getRemoteIp</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{
<a name="l00451"></a>00451         <span class="keywordflow">return</span> m_tcp_buf.<a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html#6a206b8c56b7df918c12ec73929d372f">getConnection</a>().<a class="code" href="classpion_1_1net_1_1_t_c_p_connection.html#96184b386766d1606cf88df46202c896">getRemoteIp</a>();
<a name="l00452"></a>00452     }
<a name="l00453"></a>00453     
<a name="l00455"></a><a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#ac5ebc5c7606b084bfffb04a134fa9c3">00455</a>     <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html">TCPStreamBuffer</a> *<a class="code" href="classpion_1_1net_1_1_t_c_p_stream.html#ac5ebc5c7606b084bfffb04a134fa9c3">rdbuf</a>(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> &amp;m_tcp_buf; }
<a name="l00456"></a>00456     
<a name="l00457"></a>00457     
<a name="l00458"></a>00458 <span class="keyword">private</span>:
<a name="l00459"></a>00459     
<a name="l00461"></a>00461     <a class="code" href="classpion_1_1net_1_1_t_c_p_stream_buffer.html">TCPStreamBuffer</a>     m_tcp_buf;
<a name="l00462"></a>00462 };
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 }   <span class="comment">// end namespace net</span>
<a name="l00466"></a>00466 }   <span class="comment">// end namespace pion</span>
<a name="l00467"></a>00467 
<a name="l00468"></a>00468 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Aug 10 15:23:13 2010 for pion-net by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
