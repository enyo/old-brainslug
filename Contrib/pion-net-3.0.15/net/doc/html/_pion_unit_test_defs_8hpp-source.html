<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pion-net: common/include/pion/PionUnitTestDefs.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>common/include/pion/PionUnitTestDefs.hpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment">// pion-common: a collection of common libraries used by the Pion Platform</span>
<a name="l00003"></a>00003 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (C) 2007-2008 Atomic Labs, Inc.  (http://www.atomiclabs.com)</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/LICENSE_1_0.txt</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef __PION_PIONUNITTESTDEFS_HEADER__</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define __PION_PIONUNITTESTDEFS_HEADER__</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;boost/test/unit_test.hpp&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/test/test_case_template.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;pion/PionLogger.hpp&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;direct.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">    #define CHANGE_DIRECTORY _chdir</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">    #define GET_DIRECTORY(a,b) _getcwd(a,b)</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;unistd.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">    #define CHANGE_DIRECTORY chdir</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">    #define GET_DIRECTORY(a,b) getcwd(a,b)</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#define DIRECTORY_MAX_SIZE 1000</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 
<a name="l00032"></a><a class="code" href="struct_pion_unit_test.html">00032</a> <span class="keyword">struct </span><a class="code" href="struct_pion_unit_test.html">PionUnitTest</a> {
<a name="l00033"></a>00033     <span class="comment">// This is passed to xmlSetGenericErrorFunc() to make libxml do nothing when an error</span>
<a name="l00034"></a>00034     <span class="comment">// occurs, rather than its default behavior of writing a message to stderr.</span>
<a name="l00035"></a><a class="code" href="struct_pion_unit_test.html#3d719b78361504cafcd821283b7e5ad0">00035</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="struct_pion_unit_test.html#3d719b78361504cafcd821283b7e5ad0">doNothing</a>(<span class="keywordtype">void</span>* ctx, <span class="keyword">const</span> <span class="keywordtype">char</span>* msg, ...) {
<a name="l00036"></a>00036     }
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     <span class="comment">// removes line endings from a c-style string</span>
<a name="l00039"></a><a class="code" href="struct_pion_unit_test.html#53ad958db4ae265b0f31222efbddc235">00039</a>     <span class="keyword">static</span> <span class="keywordtype">char</span>* <a class="code" href="struct_pion_unit_test.html#53ad958db4ae265b0f31222efbddc235">trim</a>(<span class="keywordtype">char</span>* str) {
<a name="l00040"></a>00040         <span class="keywordflow">for</span> (<span class="keywordtype">long</span> len = strlen(str) - 1; len &gt;= 0; len--) {
<a name="l00041"></a>00041             <span class="keywordflow">if</span> (str[len] == <span class="charliteral">'\n'</span> || str[len] == <span class="charliteral">'\r'</span>)
<a name="l00042"></a>00042                 str[len] = <span class="charliteral">'\0'</span>;
<a name="l00043"></a>00043             <span class="keywordflow">else</span>
<a name="l00044"></a>00044                 <span class="keywordflow">break</span>;
<a name="l00045"></a>00045         }
<a name="l00046"></a>00046         <span class="keywordflow">return</span> str;
<a name="l00047"></a>00047     }
<a name="l00048"></a>00048 
<a name="l00049"></a>00049     <span class="comment">// reads lines from a file, stripping line endings and ignoring blank lines</span>
<a name="l00050"></a>00050     <span class="comment">// and comment lines (starting with a '#')</span>
<a name="l00051"></a><a class="code" href="struct_pion_unit_test.html#ca3244ca5e02501a881c88c8b97e165d">00051</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_pion_unit_test.html#ca3244ca5e02501a881c88c8b97e165d">read_lines_from_file</a>(<span class="keyword">const</span> std::string&amp; filename, std::list&lt;std::string&gt;&amp; lines) {
<a name="l00052"></a>00052         <span class="comment">// open file</span>
<a name="l00053"></a>00053         std::ifstream a_file(filename.c_str(), std::ios::in | std::ios::binary);
<a name="l00054"></a>00054         <span class="keywordflow">if</span> (! a_file.is_open())
<a name="l00055"></a>00055             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057         <span class="comment">// read data from file</span>
<a name="l00058"></a>00058         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BUF_SIZE = 4096;
<a name="l00059"></a>00059         <span class="keywordtype">char</span> *ptr, buf[BUF_SIZE+1];
<a name="l00060"></a>00060         buf[BUF_SIZE] = <span class="charliteral">'\0'</span>;
<a name="l00061"></a>00061         lines.clear();
<a name="l00062"></a>00062 
<a name="l00063"></a>00063         <span class="keywordflow">while</span> (a_file.getline(buf, BUF_SIZE)) {
<a name="l00064"></a>00064             ptr = <a class="code" href="struct_pion_unit_test.html#53ad958db4ae265b0f31222efbddc235">trim</a>(buf);
<a name="l00065"></a>00065             <span class="keywordflow">if</span> (*ptr != <span class="charliteral">'\0'</span> &amp;&amp; *ptr != <span class="charliteral">'#'</span>)
<a name="l00066"></a>00066                 lines.push_back(ptr);
<a name="l00067"></a>00067         }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069         <span class="comment">// close file</span>
<a name="l00070"></a>00070         a_file.close();
<a name="l00071"></a>00071 
<a name="l00072"></a>00072         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00073"></a>00073     }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075     <span class="comment">// Check for file match, use std::list for sorting the files, which will allow</span>
<a name="l00076"></a>00076     <span class="comment">// random order matching...</span>
<a name="l00077"></a><a class="code" href="struct_pion_unit_test.html#bc59de6c7502bbd3c14bf965dbba75d3">00077</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_pion_unit_test.html#bc59de6c7502bbd3c14bf965dbba75d3">check_files_match</a>(<span class="keyword">const</span> std::string&amp; fileA, <span class="keyword">const</span> std::string&amp; fileB) {
<a name="l00078"></a>00078         <span class="comment">// open and read data from files</span>
<a name="l00079"></a>00079         std::list&lt;std::string&gt; a_lines, b_lines;
<a name="l00080"></a>00080         BOOST_REQUIRE(<a class="code" href="struct_pion_unit_test.html#ca3244ca5e02501a881c88c8b97e165d">read_lines_from_file</a>(fileA, a_lines));
<a name="l00081"></a>00081         BOOST_REQUIRE(<a class="code" href="struct_pion_unit_test.html#ca3244ca5e02501a881c88c8b97e165d">read_lines_from_file</a>(fileB, b_lines));
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <span class="comment">// sort lines read</span>
<a name="l00084"></a>00084         a_lines.sort();
<a name="l00085"></a>00085         b_lines.sort();
<a name="l00086"></a>00086 
<a name="l00087"></a>00087         <span class="comment">// files match if lines match</span>
<a name="l00088"></a>00088         <span class="keywordflow">return</span> (a_lines == b_lines);
<a name="l00089"></a>00089     }
<a name="l00090"></a>00090 
<a name="l00091"></a><a class="code" href="struct_pion_unit_test.html#3aea8e10e91ac8e924afdefdb8dc316c">00091</a>     <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="struct_pion_unit_test.html#3aea8e10e91ac8e924afdefdb8dc316c">check_files_exact_match</a>(<span class="keyword">const</span> std::string&amp; fileA, <span class="keyword">const</span> std::string&amp; fileB, <span class="keywordtype">bool</span> ignore_line_endings = <span class="keyword">false</span>) {
<a name="l00092"></a>00092         <span class="comment">// open files</span>
<a name="l00093"></a>00093         std::ifstream a_file(fileA.c_str(), std::ios::in | std::ios::binary);
<a name="l00094"></a>00094         BOOST_REQUIRE(a_file.is_open());
<a name="l00095"></a>00095 
<a name="l00096"></a>00096         std::ifstream b_file(fileB.c_str(), std::ios::in | std::ios::binary);
<a name="l00097"></a>00097         BOOST_REQUIRE(b_file.is_open());
<a name="l00098"></a>00098 
<a name="l00099"></a>00099         <span class="comment">// read and compare data in files</span>
<a name="l00100"></a>00100         <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> BUF_SIZE = 4096;
<a name="l00101"></a>00101         <span class="keywordtype">char</span> a_buf[BUF_SIZE];
<a name="l00102"></a>00102         <span class="keywordtype">char</span> b_buf[BUF_SIZE];
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="keywordflow">if</span> (ignore_line_endings) {
<a name="l00105"></a>00105             <span class="keywordflow">while</span> (a_file.getline(a_buf, BUF_SIZE)) {
<a name="l00106"></a>00106                 <span class="keywordflow">if</span> (! b_file.getline(b_buf, BUF_SIZE))
<a name="l00107"></a>00107                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00108"></a>00108                 <a class="code" href="struct_pion_unit_test.html#53ad958db4ae265b0f31222efbddc235">PionUnitTest::trim</a>(a_buf);
<a name="l00109"></a>00109                 <a class="code" href="struct_pion_unit_test.html#53ad958db4ae265b0f31222efbddc235">PionUnitTest::trim</a>(b_buf);
<a name="l00110"></a>00110                 <span class="keywordflow">if</span> (strlen(a_buf) != strlen(b_buf))
<a name="l00111"></a>00111                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00112"></a>00112                 <span class="keywordflow">if</span> (memcmp(a_buf, b_buf, strlen(a_buf)) != 0)
<a name="l00113"></a>00113                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114             }
<a name="l00115"></a>00115             <span class="keywordflow">if</span> (b_file.getline(b_buf, BUF_SIZE))
<a name="l00116"></a>00116                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00117"></a>00117         } <span class="keywordflow">else</span> {
<a name="l00118"></a>00118             <span class="keywordflow">while</span> (a_file.read(a_buf, BUF_SIZE)) {
<a name="l00119"></a>00119                 <span class="keywordflow">if</span> (! b_file.read(b_buf, BUF_SIZE))
<a name="l00120"></a>00120                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00121"></a>00121                 <span class="keywordflow">if</span> (memcmp(a_buf, b_buf, BUF_SIZE) != 0)
<a name="l00122"></a>00122                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00123"></a>00123             }
<a name="l00124"></a>00124             <span class="keywordflow">if</span> (b_file.read(b_buf, BUF_SIZE))
<a name="l00125"></a>00125                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00126"></a>00126         }
<a name="l00127"></a>00127         <span class="keywordflow">if</span> (a_file.gcount() != b_file.gcount())
<a name="l00128"></a>00128             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00129"></a>00129         <span class="keywordflow">if</span> (memcmp(a_buf, b_buf, a_file.gcount()) != 0)
<a name="l00130"></a>00130             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         a_file.close();
<a name="l00133"></a>00133         b_file.close();
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         <span class="comment">// files match</span>
<a name="l00136"></a>00136         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00137"></a>00137     }
<a name="l00138"></a>00138 };
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">// PionUnitTestsConfig is intended for use as a global fixture.  By including the </span>
<a name="l00142"></a>00142 <span class="comment">// following line in one source code file of a unit test project, the constructor will</span>
<a name="l00143"></a>00143 <span class="comment">// run once before the first test and the destructor will run once after the last test:</span>
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">// BOOST_GLOBAL_FIXTURE(PionUnitTestsConfig);</span>
<a name="l00146"></a>00146 
<a name="l00147"></a><a class="code" href="struct_pion_unit_tests_config.html">00147</a> <span class="keyword">struct </span><a class="code" href="struct_pion_unit_tests_config.html">PionUnitTestsConfig</a> {
<a name="l00148"></a><a class="code" href="struct_pion_unit_tests_config.html#def955ad30083e229f87bd1da44bb8ae">00148</a>     <a class="code" href="struct_pion_unit_tests_config.html#def955ad30083e229f87bd1da44bb8ae">PionUnitTestsConfig</a>() {
<a name="l00149"></a>00149         std::cout &lt;&lt; <span class="stringliteral">"global setup for all pion unit tests\n"</span>;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151         <span class="comment">// argc and argv do not include parameters handled by the boost unit test framework, such as --log_level.</span>
<a name="l00152"></a>00152         <span class="keywordtype">int</span> argc = boost::unit_test::framework::master_test_suite().argc;
<a name="l00153"></a>00153         <span class="keywordtype">char</span>** argv = boost::unit_test::framework::master_test_suite().argv;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155         <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;
<a name="l00156"></a>00156         <span class="keywordflow">if</span> (argc &gt; 1) {
<a name="l00157"></a>00157             <span class="keywordflow">if</span> (argv[1][0] == <span class="charliteral">'-'</span> &amp;&amp; argv[1][1] == <span class="charliteral">'v'</span>) {
<a name="l00158"></a>00158                 verbose = <span class="keyword">true</span>;
<a name="l00159"></a>00159             }
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161         PION_LOG_CONFIG_BASIC;
<a name="l00162"></a>00162         <a class="code" href="structpion_1_1_pion_logger.html">pion::PionLogger</a> log_ptr = PION_GET_LOGGER(<span class="stringliteral">"pion"</span>);
<a name="l00163"></a>00163         <span class="keywordflow">if</span> (verbose) {
<a name="l00164"></a>00164             PION_LOG_SETLEVEL_WARN(log_ptr);
<a name="l00165"></a>00165         } <span class="keywordflow">else</span> {
<a name="l00166"></a>00166             std::cout &lt;&lt; <span class="stringliteral">"Use '-v' to enable logging of errors and warnings from pion.\n"</span>;
<a name="l00167"></a>00167             PION_LOG_SETLEVEL_FATAL(log_ptr);
<a name="l00168"></a>00168         }
<a name="l00169"></a>00169     }
<a name="l00170"></a><a class="code" href="struct_pion_unit_tests_config.html#fbde964386c4909ca9ced36f42fccd28">00170</a>     <a class="code" href="struct_pion_unit_tests_config.html#fbde964386c4909ca9ced36f42fccd28">~PionUnitTestsConfig</a>() {
<a name="l00171"></a>00171         std::cout &lt;&lt; <span class="stringliteral">"global teardown for all pion unit tests\n"</span>;
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173 };
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 <span class="comment">/*</span>
<a name="l00177"></a>00177 <span class="comment">Using BOOST_AUTO_TEST_SUITE_FIXTURE_TEMPLATE and</span>
<a name="l00178"></a>00178 <span class="comment">BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE has two additional benefits relative to </span>
<a name="l00179"></a>00179 <span class="comment">using BOOST_FIXTURE_TEST_SUITE and BOOST_AUTO_TEST_CASE:</span>
<a name="l00180"></a>00180 <span class="comment">1) it allows a test to be run with more than one fixture, and</span>
<a name="l00181"></a>00181 <span class="comment">2) it makes the current fixture part of the test name, e.g. </span>
<a name="l00182"></a>00182 <span class="comment">   checkPropertyX&lt;myFixture_F&gt;</span>
<a name="l00183"></a>00183 <span class="comment"></span>
<a name="l00184"></a>00184 <span class="comment">For an example of 1), see HTTPMessageTests.cpp.</span>
<a name="l00185"></a>00185 <span class="comment"></span>
<a name="l00186"></a>00186 <span class="comment">There are probably simpler ways to achieve 2), but since it comes for free,</span>
<a name="l00187"></a>00187 <span class="comment">it makes sense to use it.  The benefit of this is that the test names don't</span>
<a name="l00188"></a>00188 <span class="comment">have to include redundant information about the fixture, e.g. </span>
<a name="l00189"></a>00189 <span class="comment">checkMyFixtureHasPropertyX.  (In this example, checkPropertyX&lt;myFixture_F&gt; is </span>
<a name="l00190"></a>00190 <span class="comment">not obviously better than checkMyFixtureHasPropertyX, but in many cases the </span>
<a name="l00191"></a>00191 <span class="comment">test names become too long and/or hard to parse, or the fixture just isn't</span>
<a name="l00192"></a>00192 <span class="comment">part of the name, making some error reports ambiguous.)</span>
<a name="l00193"></a>00193 <span class="comment"></span>
<a name="l00194"></a>00194 <span class="comment">(BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE is based on BOOST_AUTO_TEST_CASE_TEMPLATE,</span>
<a name="l00195"></a>00195 <span class="comment">in unit_test_suite.hpp.)</span>
<a name="l00196"></a>00196 <span class="comment"></span>
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment">Minimal example demonstrating usage of BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE:</span>
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment">class ObjectToTest_F { // suffix _F is used for fixtures</span>
<a name="l00201"></a>00201 <span class="comment">public:</span>
<a name="l00202"></a>00202 <span class="comment">    ObjectToTest_F() {</span>
<a name="l00203"></a>00203 <span class="comment">        m_value = 2;</span>
<a name="l00204"></a>00204 <span class="comment">    }</span>
<a name="l00205"></a>00205 <span class="comment">    int m_value;</span>
<a name="l00206"></a>00206 <span class="comment">    int getValue() { return m_value; }</span>
<a name="l00207"></a>00207 <span class="comment">};</span>
<a name="l00208"></a>00208 <span class="comment"></span>
<a name="l00209"></a>00209 <span class="comment">// This illustrates the most common case, where just one fixture will be used,</span>
<a name="l00210"></a>00210 <span class="comment">// so the list only has one fixture in it.</span>
<a name="l00211"></a>00211 <span class="comment">// ObjectToTest_S is the name of the test suite.</span>
<a name="l00212"></a>00212 <span class="comment">BOOST_AUTO_TEST_SUITE_FIXTURE_TEMPLATE(ObjectToTest_S,</span>
<a name="l00213"></a>00213 <span class="comment">                                       boost::mpl::list&lt;ObjectToTest_F&gt;)</span>
<a name="l00214"></a>00214 <span class="comment"></span>
<a name="l00215"></a>00215 <span class="comment">// One method for testing the fixture...</span>
<a name="l00216"></a>00216 <span class="comment">BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE(checkValueEqualsTwo) {</span>
<a name="l00217"></a>00217 <span class="comment">    BOOST_CHECK_EQUAL(F::m_value, 2);</span>
<a name="l00218"></a>00218 <span class="comment">    BOOST_CHECK_EQUAL(F::getValue(), 2);</span>
<a name="l00219"></a>00219 <span class="comment">}</span>
<a name="l00220"></a>00220 <span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">// Another method for testing the fixture...</span>
<a name="l00222"></a>00222 <span class="comment">BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE(checkValueEqualsTwoAgain) {</span>
<a name="l00223"></a>00223 <span class="comment">    BOOST_CHECK_EQUAL(this-&gt;m_value, 2);</span>
<a name="l00224"></a>00224 <span class="comment">    BOOST_CHECK_EQUAL(this-&gt;getValue(), 2);</span>
<a name="l00225"></a>00225 <span class="comment">}</span>
<a name="l00226"></a>00226 <span class="comment"></span>
<a name="l00227"></a>00227 <span class="comment">// The simplest, but, alas, non conformant to the C++ standard, method for testing the fixture.</span>
<a name="l00228"></a>00228 <span class="comment">// This will compile with MSVC (unless language extensions are disabled (/Za)).</span>
<a name="l00229"></a>00229 <span class="comment">// It won't compile with gcc unless -fpermissive is used.</span>
<a name="l00230"></a>00230 <span class="comment">// See http://gcc.gnu.org/onlinedocs/gcc/Name-lookup.html.</span>
<a name="l00231"></a>00231 <span class="comment">BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE(checkValueEqualsTwoNonConformant) {</span>
<a name="l00232"></a>00232 <span class="comment">    BOOST_CHECK_EQUAL(m_value, 2);</span>
<a name="l00233"></a>00233 <span class="comment">    BOOST_CHECK_EQUAL(getValue(), 2);</span>
<a name="l00234"></a>00234 <span class="comment">}</span>
<a name="l00235"></a>00235 <span class="comment"></span>
<a name="l00236"></a>00236 <span class="comment">BOOST_AUTO_TEST_SUITE_END()</span>
<a name="l00237"></a>00237 <span class="comment">*/</span>
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="preprocessor">#define BOOST_AUTO_TEST_SUITE_FIXTURE_TEMPLATE(suite_name, fixture_types) \</span>
<a name="l00240"></a>00240 <span class="preprocessor">BOOST_AUTO_TEST_SUITE(suite_name)                                         \</span>
<a name="l00241"></a>00241 <span class="preprocessor">typedef fixture_types BOOST_AUTO_TEST_CASE_FIXTURE_TYPES;                 \</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>
<a name="l00243"></a>00243 <span class="preprocessor"></span>
<a name="l00244"></a>00244 <span class="preprocessor">#define BOOST_AUTO_TEST_CASE_FIXTURE_TEMPLATE(test_name)        \</span>
<a name="l00245"></a>00245 <span class="preprocessor">template&lt;typename F&gt;                                            \</span>
<a name="l00246"></a>00246 <span class="preprocessor">struct test_name : public F                                     \</span>
<a name="l00247"></a>00247 <span class="preprocessor">{ void test_method(); };                                        \</span>
<a name="l00248"></a>00248 <span class="preprocessor">                                                                \</span>
<a name="l00249"></a>00249 <span class="preprocessor">struct BOOST_AUTO_TC_INVOKER( test_name ) {                     \</span>
<a name="l00250"></a>00250 <span class="preprocessor">    template&lt;typename TestType&gt;                                 \</span>
<a name="l00251"></a>00251 <span class="preprocessor">    static void run( boost::type&lt;TestType&gt;* = 0 )               \</span>
<a name="l00252"></a>00252 <span class="preprocessor">    {                                                           \</span>
<a name="l00253"></a>00253 <span class="preprocessor">        test_name&lt;TestType&gt; t;                                  \</span>
<a name="l00254"></a>00254 <span class="preprocessor">        t.test_method();                                        \</span>
<a name="l00255"></a>00255 <span class="preprocessor">    }                                                           \</span>
<a name="l00256"></a>00256 <span class="preprocessor">};                                                              \</span>
<a name="l00257"></a>00257 <span class="preprocessor">                                                                \</span>
<a name="l00258"></a>00258 <span class="preprocessor">BOOST_AUTO_TU_REGISTRAR( test_name )(                           \</span>
<a name="l00259"></a>00259 <span class="preprocessor">    boost::unit_test::ut_detail::template_test_case_gen&lt;        \</span>
<a name="l00260"></a>00260 <span class="preprocessor">        BOOST_AUTO_TC_INVOKER( test_name ),                     \</span>
<a name="l00261"></a>00261 <span class="preprocessor">        BOOST_AUTO_TEST_CASE_FIXTURE_TYPES &gt;(                   \</span>
<a name="l00262"></a>00262 <span class="preprocessor">            BOOST_STRINGIZE( test_name ) ) );                   \</span>
<a name="l00263"></a>00263 <span class="preprocessor">                                                                \</span>
<a name="l00264"></a>00264 <span class="preprocessor">template&lt;typename F&gt;                                            \</span>
<a name="l00265"></a>00265 <span class="preprocessor">void test_name&lt;F&gt;::test_method()                                \</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span>
<a name="l00267"></a>00267 <span class="preprocessor"></span>
<a name="l00268"></a>00268 <span class="comment">// Macro for checking that a particular exception is thrown, for situations where the type of the exception is not in scope.  </span>
<a name="l00269"></a>00269 <span class="comment">// For instance, in checkEmptyQueryMapException(), we'd really just like to say:</span>
<a name="l00270"></a>00270 <span class="comment">//      BOOST_CHECK_THROW(p-&gt;setConfig(*m_vocab, config_ptr), pion::plugins::WebTrendsAnalyticsReactor::EmptyQueryMap);</span>
<a name="l00271"></a>00271 <span class="comment">// but pion::plugins::WebTrendsAnalyticsReactor::EmptyQueryMap isn't defined, and the overhead to bring it into scope is prohibitive.</span>
<a name="l00272"></a>00272 <span class="preprocessor">#define CHECK_THROW_WITH_SPECIFIC_MESSAGE(S, M) \</span>
<a name="l00273"></a>00273 <span class="preprocessor">    bool exception_caught = false;              \</span>
<a name="l00274"></a>00274 <span class="preprocessor">    try {                                       \</span>
<a name="l00275"></a>00275 <span class="preprocessor">        S;                                      \</span>
<a name="l00276"></a>00276 <span class="preprocessor">    } catch (pion::PionException&amp; e) {          \</span>
<a name="l00277"></a>00277 <span class="preprocessor">        exception_caught = true;                \</span>
<a name="l00278"></a>00278 <span class="preprocessor">        BOOST_CHECK_EQUAL(e.what(), M);         \</span>
<a name="l00279"></a>00279 <span class="preprocessor">    }                                           \</span>
<a name="l00280"></a>00280 <span class="preprocessor">    BOOST_CHECK(exception_caught);</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span>
<a name="l00282"></a>00282 
<a name="l00283"></a>00283 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Aug 10 15:23:13 2010 for pion-net by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
