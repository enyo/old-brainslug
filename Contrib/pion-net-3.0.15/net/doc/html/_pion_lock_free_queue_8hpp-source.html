<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>pion-net: common/include/pion/PionLockFreeQueue.hpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>common/include/pion/PionLockFreeQueue.hpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l00002"></a>00002 <span class="comment">// pion-common: a collection of common libraries used by the Pion Platform</span>
<a name="l00003"></a>00003 <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l00004"></a>00004 <span class="comment">// Copyright (C) 2007-2008 Atomic Labs, Inc.  (http://www.atomiclabs.com)</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/LICENSE_1_0.txt</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef __PION_PIONLOCKFREEQUEUE_HEADER__</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define __PION_PIONLOCKFREEQUEUE_HEADER__</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#ifndef PION_HAVE_LOCKFREE</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">    #error "PionLockFreeQueue requires the boost::lockfree library!"</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;iso646.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">    #pragma warning(push)</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(disable: 4800) // forcing value to bool 'true' or 'false' (performance warning)</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/lockfree/detail/tagged_ptr.hpp&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(pop)</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/lockfree/detail/cas.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/lockfree/detail/freelist.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/lockfree/detail/branch_hints.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/detail/atomic_count.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/noncopyable.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/thread/thread.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;pion/PionConfig.hpp&gt;</span>
<a name="l00032"></a>00032 <span class="comment">//#include &lt;boost/array.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="comment">//#include &lt;boost/cstdint.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="comment">//#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">// NOTE: the data structures contained in this file are based upon algorithms</span>
<a name="l00038"></a>00038 <span class="comment">// published in the paper "Simple, Fast, and Practical Non-Blocking and Blocking</span>
<a name="l00039"></a>00039 <span class="comment">// Concurrent Queue Algorithms" (1996, Maged M. Michael and Michael L. Scott,</span>
<a name="l00040"></a>00040 <span class="comment">// Department of Computer Science, University of Rochester).</span>
<a name="l00041"></a>00041 <span class="comment">// See http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">namespace </span>pion {    <span class="comment">// begin namespace pion</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 
<a name="l00050"></a>00050 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00051"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html">00051</a> <span class="keyword">class </span><a class="code" href="classpion_1_1_pion_lock_free_queue.html">PionLockFreeQueue</a> :
<a name="l00052"></a>00052     <span class="keyword">private</span> boost::noncopyable
<a name="l00053"></a>00053 {
<a name="l00054"></a>00054 <span class="keyword">protected</span>:
<a name="l00055"></a>00055     
<a name="l00057"></a><a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">00057</a>     <span class="keyword">struct </span><a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> {
<a name="l00059"></a><a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#b9ea4e3b4ac4c4d3d641e55d171321c3">00059</a>         <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#b9ea4e3b4ac4c4d3d641e55d171321c3">QueueNode</a>(<span class="keywordtype">void</span>) : <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#9fe5a3f60d8e7e3b890ecf6d18794d85">next</a>(NULL) {}
<a name="l00060"></a>00060         
<a name="l00062"></a><a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#bda93c49884db6c8d08c6842345c10d2">00062</a>         <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#b9ea4e3b4ac4c4d3d641e55d171321c3">QueueNode</a>(<span class="keyword">const</span> T&amp; d) : <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#9fe5a3f60d8e7e3b890ecf6d18794d85">next</a>(NULL), <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#1eea540bf3903edeac7a3dc8b919b753">data</a>(d) {}
<a name="l00063"></a>00063         
<a name="l00065"></a><a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#9fe5a3f60d8e7e3b890ecf6d18794d85">00065</a>         <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">boost::lockfree::tagged_ptr&lt;QueueNode&gt;</a>  <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#9fe5a3f60d8e7e3b890ecf6d18794d85">next</a>;
<a name="l00066"></a>00066 
<a name="l00068"></a><a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#1eea540bf3903edeac7a3dc8b919b753">00068</a>         T   <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#1eea540bf3903edeac7a3dc8b919b753">data</a>;
<a name="l00069"></a>00069     };
<a name="l00070"></a>00070     
<a name="l00072"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">00072</a>     <span class="keyword">typedef</span> <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">boost::lockfree::tagged_ptr&lt;QueueNode&gt;</a>  <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">QueueNodePtr</a>;
<a name="l00073"></a>00073     
<a name="l00075"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#1bd31a55f542c5a00f0dca72b3fb43f2">00075</a>     <span class="keyword">inline</span> <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> *<a class="code" href="classpion_1_1_pion_lock_free_queue.html#1bd31a55f542c5a00f0dca72b3fb43f2">createNode</a>(<span class="keywordtype">void</span>) {
<a name="l00076"></a>00076         <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> *node_ptr = m_free_list.<a class="code" href="classboost_1_1lockfree_1_1caching__freelist.html#df82f1f7c0d5b65459846dd2a6b0c654">allocate</a>();
<a name="l00077"></a>00077         <span class="keyword">new</span>(node_ptr) <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a>();
<a name="l00078"></a>00078         <span class="keywordflow">return</span> node_ptr;
<a name="l00079"></a>00079     }
<a name="l00080"></a>00080     
<a name="l00082"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#7e5ac670d8efc5f15d84d99efeb62537">00082</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#7e5ac670d8efc5f15d84d99efeb62537">destroyNode</a>(<a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> *node_ptr) {
<a name="l00083"></a>00083         node_ptr-&gt;~QueueNode();
<a name="l00084"></a>00084         m_free_list.<a class="code" href="classboost_1_1lockfree_1_1caching__freelist.html#3902b634fa36f2693b3545ec4ece98ba">deallocate</a>(node_ptr);
<a name="l00085"></a>00085     }
<a name="l00086"></a>00086     
<a name="l00087"></a>00087     
<a name="l00088"></a>00088 <span class="keyword">public</span>:
<a name="l00089"></a>00089     
<a name="l00091"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#2458620bff8bec062dca2d994dffb3a4">00091</a>     <a class="code" href="classpion_1_1_pion_lock_free_queue.html#2458620bff8bec062dca2d994dffb3a4">PionLockFreeQueue</a>(<span class="keywordtype">void</span>) : m_size(0) {
<a name="l00092"></a>00092         <span class="comment">// initialize with a dummy node since m_head_ptr is always </span>
<a name="l00093"></a>00093         <span class="comment">// pointing to the item before the head of the list</span>
<a name="l00094"></a>00094         <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> *dummy_ptr = <a class="code" href="classpion_1_1_pion_lock_free_queue.html#1bd31a55f542c5a00f0dca72b3fb43f2">createNode</a>();
<a name="l00095"></a>00095         m_head_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#92f6e29528609695332ea88cfb8e4210">set_ptr</a>(dummy_ptr);
<a name="l00096"></a>00096         m_tail_ptr.set_ptr(dummy_ptr);
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     
<a name="l00100"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#04fced18d5cc7fb934a1f13fe1ef147d">00100</a>     <span class="keyword">virtual</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#04fced18d5cc7fb934a1f13fe1ef147d">~PionLockFreeQueue</a>() {
<a name="l00101"></a>00101         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#c936131a1e2bf1c605c1ff752c1b7f02">clear</a>();
<a name="l00102"></a>00102         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#7e5ac670d8efc5f15d84d99efeb62537">destroyNode</a>(m_head_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>());
<a name="l00103"></a>00103     }
<a name="l00104"></a>00104     
<a name="l00106"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#e1a851aec8511b02a1b0344fc54d502b">00106</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#e1a851aec8511b02a1b0344fc54d502b">empty</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{
<a name="l00107"></a>00107         <span class="keywordflow">return</span> (m_head_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>() == m_tail_ptr.get_ptr());
<a name="l00108"></a>00108     }
<a name="l00109"></a>00109     
<a name="l00111"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#366f395fc7b549012f44752de72824b7">00111</a>     <span class="keyword">inline</span> std::size_t <a class="code" href="classpion_1_1_pion_lock_free_queue.html#366f395fc7b549012f44752de72824b7">size</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{
<a name="l00112"></a>00112         <span class="keywordflow">return</span> m_size;
<a name="l00113"></a>00113     }
<a name="l00114"></a>00114     
<a name="l00117"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#c936131a1e2bf1c605c1ff752c1b7f02">00117</a>     <span class="keyword">volatile</span> <span class="keywordtype">void</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#c936131a1e2bf1c605c1ff752c1b7f02">clear</a>(<span class="keywordtype">void</span>) {
<a name="l00118"></a>00118         <span class="keywordflow">while</span> (! <a class="code" href="classpion_1_1_pion_lock_free_queue.html#e1a851aec8511b02a1b0344fc54d502b">empty</a>()) {
<a name="l00119"></a>00119             <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">QueueNodePtr</a> node_ptr(m_head_ptr);
<a name="l00120"></a>00120             m_head_ptr = m_head_ptr-&gt;next;
<a name="l00121"></a>00121             <a class="code" href="classpion_1_1_pion_lock_free_queue.html#7e5ac670d8efc5f15d84d99efeb62537">destroyNode</a>(node_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>());
<a name="l00122"></a>00122             --m_size;
<a name="l00123"></a>00123         }
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125     
<a name="l00131"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#cb67291f34288c54390f8915799712ad">00131</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#cb67291f34288c54390f8915799712ad">push</a>(<span class="keyword">const</span> T&amp; t) {
<a name="l00132"></a>00132         <span class="comment">// create a new list node for the queue item</span>
<a name="l00133"></a>00133         <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> *node_ptr = <a class="code" href="classpion_1_1_pion_lock_free_queue.html#1bd31a55f542c5a00f0dca72b3fb43f2">createNode</a>();
<a name="l00134"></a>00134         node_ptr-&gt;<a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#1eea540bf3903edeac7a3dc8b919b753">data</a> = t;
<a name="l00135"></a>00135         
<a name="l00136"></a>00136         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00137"></a>00137             <span class="comment">// get copy of tail pointer</span>
<a name="l00138"></a>00138             <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">QueueNodePtr</a> tail_ptr(m_tail_ptr);
<a name="l00139"></a>00139             <span class="comment">//boost::lockfree::memory_barrier();</span>
<a name="l00140"></a>00140 
<a name="l00141"></a>00141             <span class="comment">// get copy of tail's next pointer</span>
<a name="l00142"></a>00142             <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">QueueNodePtr</a> next_ptr(tail_ptr-&gt;next);
<a name="l00143"></a>00143             <a class="code" href="namespaceboost_1_1lockfree.html#bf70357fb7ad263c2a798d1746c895d9">boost::lockfree::memory_barrier</a>();
<a name="l00144"></a>00144             
<a name="l00145"></a>00145             <span class="comment">// make sure that the tail pointer has not changed since reading next</span>
<a name="l00146"></a>00146             <span class="keywordflow">if</span> (<a class="code" href="namespaceboost_1_1lockfree.html#7edfb617a8010d8d5f322a46f6eda1be">boost::lockfree::likely</a>(tail_ptr == m_tail_ptr)) {
<a name="l00147"></a>00147                 <span class="comment">// check if tail was pointing to the last node</span>
<a name="l00148"></a>00148                 <span class="keywordflow">if</span> (next_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>() == NULL) {
<a name="l00149"></a>00149                     <span class="comment">// try to link the new node at the end of the list</span>
<a name="l00150"></a>00150                     <span class="keywordflow">if</span> (tail_ptr-&gt;next.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#e11125fd877dc6ccde2cd38ba76061a4">cas</a>(next_ptr, node_ptr)) {
<a name="l00151"></a>00151                         <span class="comment">// done with enqueue; try to swing tail to the inserted node</span>
<a name="l00152"></a>00152                         m_tail_ptr.cas(tail_ptr, node_ptr);
<a name="l00153"></a>00153                         <span class="keywordflow">break</span>;
<a name="l00154"></a>00154                     }
<a name="l00155"></a>00155                 } <span class="keywordflow">else</span> {
<a name="l00156"></a>00156                     <span class="comment">// try to swing tail to the next node</span>
<a name="l00157"></a>00157                     m_tail_ptr.cas(tail_ptr, next_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>());
<a name="l00158"></a>00158                 }
<a name="l00159"></a>00159             }
<a name="l00160"></a>00160         }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         <span class="comment">// increment size</span>
<a name="l00163"></a>00163         ++m_size;
<a name="l00164"></a>00164     }   
<a name="l00165"></a>00165     
<a name="l00173"></a><a class="code" href="classpion_1_1_pion_lock_free_queue.html#9c55d297410b7267a9d5e010407e5aa8">00173</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#9c55d297410b7267a9d5e010407e5aa8">pop</a>(T&amp; t) {
<a name="l00174"></a>00174         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00175"></a>00175             <span class="comment">// get copy of head pointer</span>
<a name="l00176"></a>00176             <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">QueueNodePtr</a> head_ptr(m_head_ptr);
<a name="l00177"></a>00177             <span class="comment">//boost::lockfree::memory_barrier();</span>
<a name="l00178"></a>00178 
<a name="l00179"></a>00179             <span class="comment">// get copy of tail pointer</span>
<a name="l00180"></a>00180             <a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html">QueueNodePtr</a> tail_ptr(m_tail_ptr);
<a name="l00181"></a>00181             <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html">QueueNode</a> *next_ptr = head_ptr-&gt;next.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>();
<a name="l00182"></a>00182             <a class="code" href="namespaceboost_1_1lockfree.html#bf70357fb7ad263c2a798d1746c895d9">boost::lockfree::memory_barrier</a>();
<a name="l00183"></a>00183             
<a name="l00184"></a>00184             <span class="comment">// check consistency of head pointer</span>
<a name="l00185"></a>00185             <span class="keywordflow">if</span> (<a class="code" href="namespaceboost_1_1lockfree.html#7edfb617a8010d8d5f322a46f6eda1be">boost::lockfree::likely</a>(head_ptr == m_head_ptr)) {
<a name="l00186"></a>00186 
<a name="l00187"></a>00187                 <span class="comment">// check if queue is empty, or tail is falling behind</span>
<a name="l00188"></a>00188                 <span class="keywordflow">if</span> (head_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>() == tail_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>()) {
<a name="l00189"></a>00189                     <span class="comment">// is queue empty?</span>
<a name="l00190"></a>00190                     <span class="keywordflow">if</span> (next_ptr == NULL)
<a name="l00191"></a>00191                         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// queue is empty</span>
<a name="l00192"></a>00192                     
<a name="l00193"></a>00193                     <span class="comment">// not empty; try to advance tail to catch it up</span>
<a name="l00194"></a>00194                     m_tail_ptr.cas(tail_ptr, next_ptr);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196                 } <span class="keywordflow">else</span> {
<a name="l00197"></a>00197                     <span class="comment">// tail is OK</span>
<a name="l00198"></a>00198                     <span class="comment">// read value before CAS, otherwise another dequeue</span>
<a name="l00199"></a>00199                     <span class="comment">//   might free the next node</span>
<a name="l00200"></a>00200                     t = next_ptr-&gt;<a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#1eea540bf3903edeac7a3dc8b919b753">data</a>;
<a name="l00201"></a>00201                     
<a name="l00202"></a>00202                     <span class="comment">// try to swing head to the next node</span>
<a name="l00203"></a>00203                     <span class="keywordflow">if</span> (m_head_ptr.cas(head_ptr, next_ptr)) {
<a name="l00204"></a>00204                         <span class="comment">// success -&gt; nuke the old head item</span>
<a name="l00205"></a>00205                         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#7e5ac670d8efc5f15d84d99efeb62537">destroyNode</a>(head_ptr.<a class="code" href="classboost_1_1lockfree_1_1tagged__ptr.html#465f241e8e107c36cd75237aca02aeb1">get_ptr</a>());
<a name="l00206"></a>00206                         <span class="keywordflow">break</span>;  <span class="comment">// exit loop</span>
<a name="l00207"></a>00207                     }
<a name="l00208"></a>00208                 }
<a name="l00209"></a>00209             }
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211         
<a name="l00212"></a>00212         <span class="comment">// decrement size</span>
<a name="l00213"></a>00213         --m_size;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215         <span class="comment">// item successfully retrieved</span>
<a name="l00216"></a>00216         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     
<a name="l00220"></a>00220 <span class="keyword">private</span>:
<a name="l00221"></a>00221     
<a name="l00223"></a>00223     <span class="keyword">typedef</span> <a class="code" href="classboost_1_1lockfree_1_1caching__freelist.html">boost::lockfree::caching_freelist&lt;QueueNode&gt;</a>    NodeFreeList;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225     
<a name="l00227"></a>00227     boost::detail::atomic_count     m_size;
<a name="l00228"></a>00228 
<a name="l00230"></a>00230     NodeFreeList        m_free_list;
<a name="l00231"></a>00231     
<a name="l00233"></a>00233     <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>        m_head_ptr;
<a name="l00234"></a>00234     
<a name="l00236"></a>00236 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span><span class="preprocessor">    #pragma pack(8) </span><span class="comment">/* force head_ and tail_ to different cache lines! */</span>
<a name="l00238"></a>00238     <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>        m_tail_ptr;
<a name="l00239"></a>00239 <span class="preprocessor">#else</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>    <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>        m_tail_ptr __attribute__((aligned(64))); <span class="comment">/* force head_ and tail_ to different cache lines! */</span>
<a name="l00241"></a>00241 <span class="preprocessor">#endif</span>
<a name="l00242"></a>00242 <span class="preprocessor"></span>};
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     
<a name="l00247"></a>00247 <span class="preprocessor">#if 0</span>
<a name="l00252"></a>00252 <span class="preprocessor">template &lt;typename T,</span>
<a name="l00253"></a>00253 <span class="preprocessor"></span>    boost::uint16_t MaxSize = 50000,
<a name="l00254"></a>00254     boost::uint32_t SleepMilliSec = 10 &gt;
<a name="l00255"></a>00255 <span class="keyword">class </span>PionLockFreeQueue :
<a name="l00256"></a>00256     <span class="keyword">private</span> boost::noncopyable
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258 <span class="keyword">protected</span>:
<a name="l00259"></a>00259 
<a name="l00261"></a>00261     BOOST_STATIC_ASSERT(<span class="keyword">sizeof</span>(boost::uint32_t) &gt;= (<span class="keyword">sizeof</span>(boost::uint16_t) * 2));
<a name="l00262"></a>00262 
<a name="l00264"></a>00264     <span class="keyword">union </span><a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> {
<a name="l00266"></a>00266         <span class="keyword">struct </span>{
<a name="l00268"></a>00268             boost::uint16_t     index;
<a name="l00270"></a>00270             boost::uint16_t     counter;
<a name="l00271"></a>00271         } data;
<a name="l00273"></a>00273         boost::int32_t      value;
<a name="l00274"></a>00274     };  
<a name="l00275"></a>00275 
<a name="l00277"></a>00277     <span class="keyword">struct </span>QueueNode {
<a name="l00279"></a>00279         <a class="code" href="structpion_1_1_pion_lock_free_queue_1_1_queue_node.html#b9ea4e3b4ac4c4d3d641e55d171321c3">QueueNode</a>(<span class="keywordtype">void</span>) { m_next.value = 0; }
<a name="l00281"></a>00281         T                           m_data;
<a name="l00283"></a>00283         <span class="keyword">volatile</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>       m_next;
<a name="l00284"></a>00284     };
<a name="l00285"></a>00285     
<a name="l00293"></a>00293     <span class="keyword">inline</span> QueueNode&amp; getQueueNode(<a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> node_ptr) {
<a name="l00294"></a>00294         <span class="keywordflow">return</span> m_nodes[node_ptr.data.index];
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296     
<a name="l00306"></a>00306     <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(<span class="keyword">volatile</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>&amp; cur_ptr, <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> old_ptr,
<a name="l00307"></a>00307         boost::uint16_t new_index)
<a name="l00308"></a>00308     {
<a name="l00309"></a>00309         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> new_ptr;
<a name="l00310"></a>00310         new_ptr.data.index = new_index;
<a name="l00311"></a>00311         new_ptr.data.counter = old_ptr.data.counter + 1;
<a name="l00312"></a>00312         <span class="keywordflow">return</span> <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">boost::lockfree::cas</a>(&amp;(cur_ptr.value), old_ptr.value, new_ptr.value);
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314     
<a name="l00316"></a>00316     <span class="keyword">inline</span> boost::uint16_t acquireNode(<span class="keywordtype">void</span>) {
<a name="l00317"></a>00317         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>    current_free_ptr;
<a name="l00318"></a>00318         boost::uint16_t new_free_index;
<a name="l00319"></a>00319         boost::uint16_t avail_index;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00322"></a>00322             <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00323"></a>00323                 <span class="comment">// get current free_ptr value</span>
<a name="l00324"></a>00324                 current_free_ptr.value = m_free_ptr.value;
<a name="l00325"></a>00325                 <span class="comment">// check if current free_ptr value == 0</span>
<a name="l00326"></a>00326                 <span class="keywordflow">if</span> (current_free_ptr.data.index &gt; 0)
<a name="l00327"></a>00327                     <span class="keywordflow">break</span>;
<a name="l00328"></a>00328                 <span class="comment">// sleep while MaxSize is exceeded</span>
<a name="l00329"></a>00329                 boost::system_time wakeup_time = boost::get_system_time()
<a name="l00330"></a>00330                     + boost::posix_time::millisec(SleepMilliSec);
<a name="l00331"></a>00331                 boost::thread::sleep(wakeup_time);
<a name="l00332"></a>00332             }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334             <span class="comment">// prepare what will become the new free_ptr index value</span>
<a name="l00335"></a>00335             new_free_index = current_free_ptr.data.index - 1;
<a name="l00336"></a>00336             
<a name="l00337"></a>00337             <span class="comment">// optimisticly get the next available node index</span>
<a name="l00338"></a>00338             avail_index = m_free_nodes[new_free_index];
<a name="l00339"></a>00339 
<a name="l00340"></a>00340             <span class="comment">// use cas operation to update free_ptr value</span>
<a name="l00341"></a>00341             <span class="keywordflow">if</span> (avail_index != 0
<a name="l00342"></a>00342                 &amp;&amp; <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(m_free_ptr, current_free_ptr, new_free_index))
<a name="l00343"></a>00343             {
<a name="l00344"></a>00344                 m_free_nodes[new_free_index] = 0;
<a name="l00345"></a>00345                 <span class="keywordflow">break</span>;  <span class="comment">// cas successful - all done!</span>
<a name="l00346"></a>00346             }
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348         
<a name="l00349"></a>00349         <span class="keywordflow">return</span> avail_index;
<a name="l00350"></a>00350     }
<a name="l00351"></a>00351 
<a name="l00353"></a>00353     <span class="keyword">inline</span> <span class="keywordtype">void</span> releaseNode(<span class="keyword">const</span> boost::uint16_t node_index) {
<a name="l00354"></a>00354         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>    current_free_ptr;
<a name="l00355"></a>00355         boost::uint16_t new_free_index;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00358"></a>00358             <span class="comment">// get current free_ptr value</span>
<a name="l00359"></a>00359             current_free_ptr.value = m_free_ptr.value;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361             <span class="comment">// prepare what will become the new free_ptr index value</span>
<a name="l00362"></a>00362             new_free_index = current_free_ptr.data.index + 1;
<a name="l00363"></a>00363 
<a name="l00364"></a>00364             <span class="comment">// use cas operation to update free_ptr value</span>
<a name="l00365"></a>00365             <span class="keywordflow">if</span> (m_free_nodes[current_free_ptr.data.index] == 0
<a name="l00366"></a>00366                 &amp;&amp; <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(m_free_ptr, current_free_ptr, new_free_index))
<a name="l00367"></a>00367             {
<a name="l00368"></a>00368                 <span class="comment">// push the available index value into the next free position</span>
<a name="l00369"></a>00369                 m_free_nodes[current_free_ptr.data.index] = node_index;
<a name="l00370"></a>00370                 
<a name="l00371"></a>00371                 <span class="comment">// all done!</span>
<a name="l00372"></a>00372                 <span class="keywordflow">break</span>;
<a name="l00373"></a>00373             }
<a name="l00374"></a>00374         }
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376     
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">public</span>:
<a name="l00379"></a>00379 
<a name="l00381"></a>00381     <span class="keyword">virtual</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#04fced18d5cc7fb934a1f13fe1ef147d">~PionLockFreeQueue</a>() {}
<a name="l00382"></a>00382 
<a name="l00384"></a>00384     <a class="code" href="classpion_1_1_pion_lock_free_queue.html#2458620bff8bec062dca2d994dffb3a4">PionLockFreeQueue</a>(<span class="keywordtype">void</span>)
<a name="l00385"></a>00385     {
<a name="l00386"></a>00386         <span class="comment">// point head and tail to the node at index 1 (0 is reserved for NULL)</span>
<a name="l00387"></a>00387         m_head_ptr.data.index = m_tail_ptr.data.index = 1;
<a name="l00388"></a>00388         m_head_ptr.data.counter = m_tail_ptr.data.counter = 0;
<a name="l00389"></a>00389         <span class="comment">// initialize free_ptr to zero</span>
<a name="l00390"></a>00390         m_free_ptr.value = 0;
<a name="l00391"></a>00391         <span class="comment">// initialize free_nodes to zero</span>
<a name="l00392"></a>00392         <span class="keywordflow">for</span> (boost::uint16_t n = 0; n &lt; MaxSize; ++n)
<a name="l00393"></a>00393             m_free_nodes[n] = 0;
<a name="l00394"></a>00394         <span class="comment">// initialize next values to zero</span>
<a name="l00395"></a>00395         <span class="keywordflow">for</span> (boost::uint16_t n = 0; n &lt; MaxSize+2; ++n)
<a name="l00396"></a>00396             m_nodes[n].m_next.value = 0;
<a name="l00397"></a>00397         <span class="comment">// push everything but the first two nodes into the available stack</span>
<a name="l00398"></a>00398         for (boost::uint16_t n = 2; n &lt; MaxSize+2; ++n)
<a name="l00399"></a>00399             releaseNode(n);
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401     
<a name="l00403"></a>00403     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#e1a851aec8511b02a1b0344fc54d502b">empty</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_free_ptr.data.index == 0; }
<a name="l00404"></a>00404 
<a name="l00406"></a>00406     <span class="keyword">inline</span> boost::uint16_t <a class="code" href="classpion_1_1_pion_lock_free_queue.html#366f395fc7b549012f44752de72824b7">size</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_free_ptr.data.index; }
<a name="l00407"></a>00407     
<a name="l00413"></a>00413     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#cb67291f34288c54390f8915799712ad">push</a>(<span class="keyword">const</span> T&amp; t) {
<a name="l00414"></a>00414         <span class="comment">// retrieve a new list node for the queue item</span>
<a name="l00415"></a>00415         <span class="keyword">const</span> boost::uint16_t node_index(acquireNode());
<a name="l00416"></a>00416 
<a name="l00417"></a>00417         <span class="comment">// prepare it to be added to the list</span>
<a name="l00418"></a>00418         QueueNode&amp; node_ref = m_nodes[node_index];
<a name="l00419"></a>00419         node_ref.m_data = t;
<a name="l00420"></a>00420         node_ref.m_next.data.index = 0;
<a name="l00421"></a>00421 
<a name="l00422"></a>00422         <span class="comment">// append node to the end of the list</span>
<a name="l00423"></a>00423         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> tail_ptr;
<a name="l00424"></a>00424         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> next_ptr;
<a name="l00425"></a>00425         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00426"></a>00426             tail_ptr.value = m_tail_ptr.value;
<a name="l00427"></a>00427             next_ptr.value = getQueueNode(tail_ptr).m_next.value;
<a name="l00428"></a>00428             <span class="comment">// make sure that the tail pointer has not changed since reading next</span>
<a name="l00429"></a>00429             <span class="keywordflow">if</span> (tail_ptr.value == m_tail_ptr.value) {
<a name="l00430"></a>00430                 <span class="comment">// check if tail was pointing to the last node</span>
<a name="l00431"></a>00431                 <span class="keywordflow">if</span> (next_ptr.data.index == 0) {
<a name="l00432"></a>00432                     <span class="comment">// try to link the new node at the end of the list</span>
<a name="l00433"></a>00433                     <span class="keywordflow">if</span> (<a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(getQueueNode(tail_ptr).m_next, next_ptr, node_index))
<a name="l00434"></a>00434                         <span class="keywordflow">break</span>;
<a name="l00435"></a>00435                 } <span class="keywordflow">else</span> {
<a name="l00436"></a>00436                     <span class="comment">// try to swing tail to the next node</span>
<a name="l00437"></a>00437                     <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(m_tail_ptr, tail_ptr, next_ptr.data.index);
<a name="l00438"></a>00438                 }
<a name="l00439"></a>00439             }
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441         
<a name="l00442"></a>00442         <span class="comment">// done with enqueue; try to swing tail to the inserted node</span>
<a name="l00443"></a>00443         <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(m_tail_ptr, tail_ptr, node_index);
<a name="l00444"></a>00444     }
<a name="l00445"></a>00445     
<a name="l00453"></a>00453     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#9c55d297410b7267a9d5e010407e5aa8">pop</a>(T&amp; t) {
<a name="l00454"></a>00454         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> head_ptr;
<a name="l00455"></a>00455         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> tail_ptr;
<a name="l00456"></a>00456         <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a> next_ptr;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458         <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l00459"></a>00459             <span class="comment">// read current pointer values</span>
<a name="l00460"></a>00460             head_ptr.value = m_head_ptr.value;
<a name="l00461"></a>00461             tail_ptr.value = m_tail_ptr.value;
<a name="l00462"></a>00462             next_ptr.value = getQueueNode(head_ptr).m_next.value;
<a name="l00463"></a>00463             <span class="comment">// check consistency</span>
<a name="l00464"></a>00464             <span class="keywordflow">if</span> (head_ptr.value == m_head_ptr.value) {
<a name="l00465"></a>00465                 <span class="comment">// check if queue is empty, or tail is falling behind</span>
<a name="l00466"></a>00466                 <span class="keywordflow">if</span> (head_ptr.data.index == tail_ptr.data.index) {
<a name="l00467"></a>00467                     <span class="comment">// is queue empty?</span>
<a name="l00468"></a>00468                     <span class="keywordflow">if</span> (next_ptr.data.index == 0)
<a name="l00469"></a>00469                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00470"></a>00470                     <span class="comment">// not empty; try to advance tail to catch it up</span>
<a name="l00471"></a>00471                     <a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(m_tail_ptr, tail_ptr, next_ptr.data.index);
<a name="l00472"></a>00472                 } <span class="keywordflow">else</span> {
<a name="l00473"></a>00473                     <span class="comment">// tail is OK</span>
<a name="l00474"></a>00474                     <span class="comment">// read value before CAS, otherwise another dequeue might</span>
<a name="l00475"></a>00475                     <span class="comment">// free the next node</span>
<a name="l00476"></a>00476                     t = getQueueNode(next_ptr).m_data;
<a name="l00477"></a>00477                     <span class="comment">// try to swing head to the next node</span>
<a name="l00478"></a>00478                     <span class="keywordflow">if</span> (<a class="code" href="namespaceboost_1_1lockfree.html#cb78708660d5b67e2a0b3d101b7523ad">cas</a>(m_head_ptr, head_ptr, next_ptr.data.index))
<a name="l00479"></a>00479                         <span class="keywordflow">break</span>;  <span class="comment">// success -&gt; exit loop</span>
<a name="l00480"></a>00480                 }
<a name="l00481"></a>00481             }
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484         <span class="comment">// item successfully retrieved</span>
<a name="l00485"></a>00485         releaseNode(const_cast&lt;boost::uint16_t&amp;&gt;(head_ptr.data.index));
<a name="l00486"></a>00486         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488 
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keyword">private</span>:
<a name="l00491"></a>00491     
<a name="l00493"></a>00493     boost::array&lt;QueueNode, MaxSize+2&gt;      m_nodes;
<a name="l00494"></a>00494     
<a name="l00496"></a>00496     boost::array&lt;volatile boost::uint16_t, MaxSize&gt; m_free_nodes;
<a name="l00497"></a>00497     
<a name="l00499"></a>00499     <span class="keyword">volatile</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>                   m_head_ptr;
<a name="l00500"></a>00500 
<a name="l00502"></a>00502     <span class="keyword">volatile</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>                   m_tail_ptr;
<a name="l00503"></a>00503 
<a name="l00505"></a>00505     <span class="keyword">volatile</span> <a class="code" href="classpion_1_1_pion_lock_free_queue.html#edad61ac8ee497bb6cf6ec42fedb8b1a">QueueNodePtr</a>                   m_free_ptr;
<a name="l00506"></a>00506 };
<a name="l00507"></a>00507 <span class="preprocessor">#endif</span>
<a name="l00508"></a>00508 <span class="preprocessor"></span>
<a name="l00509"></a>00509 }   <span class="comment">// end namespace pion</span>
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Aug 10 15:23:13 2010 for pion-net by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
